// Saurav's Generative Phrase Maker
// Copyright (c) 2026 Saurav Plays Piano
// Licensed under the MIT License

desc:Phrase Maker
tags:MIDI generator synthesis
author:Saurav Plays Piano
version:1.0.0

// === MUSICAL SETTINGS ===
slider1:0<0,11,1{C,C#,D,D#,E,F,F#,G,G#,A,A#,B}>Root Note
slider2:0<0,2,1{Major (bright happy),Minor (dark sad),Dorian (jazzy bittersweet)}>Scale
slider3:0<0,11,1{I,II,III,IV,V,VI,VII,i,ii,iii,iv,v}>Current Chord (Roman Numeral)

// === RANGE SETTINGS ===
slider4:3<0,5,1{C1,C2,C3,C4,C5,C6}>Base Octave
slider5:2<1,4,1>Octave Range

// === PHRASE SETTINGS ===
slider6:3<2,8,1>Min Phrase Length
slider7:7<3,20,1>Max Phrase Length
slider8:1<0,1,{Off,On}>Use Passing Tones
slider9:0.5<0.1,1,0.05>Density (sparse to busy)
slider13:0.2<0,1,0.05>8th Note Amount

// === PERFORMANCE ===
slider10:40<1,127,1>Min Velocity
slider11:100<1,127,1>Max Velocity

// === SYSTEM ===
slider12:1<0,1,{Off,On}>Enable Generation
slider14:0<0,127,1>MIDI Channel (0=all)

in_pin:none
out_pin:none

@init
// ============================================
// CONSTANTS
// ============================================

// Weight constants for note selection
CHORD_TONE_WEIGHT = 95;
SCALE_TONE_WEIGHT = 4;
PASSING_TONE_WEIGHT = 1;

// Probability constants
PASSING_TONE_PROB_ENABLED = 0.12;
REPEAT_CHORD_PROB = 0.15;
REPEAT_SCALE_PROB = 0.08;
REPEAT_PASSING_PROB = 0.03;

// Boundary extension in semitones
SOFT_BOUNDARY_EXTENSION = 5;

// ============================================
// MEMORY LAYOUT - SCALE DEFINITIONS
// ============================================

// Scale intervals (semitones from root)
// Major: W W H W W W H
scale_major = 0; // Array index
scale_major[0] = 0; scale_major[1] = 2; scale_major[2] = 4; scale_major[3] = 5;
scale_major[4] = 7; scale_major[5] = 9; scale_major[6] = 11;

// Minor: W H W W H W W
scale_minor = 10;
scale_minor[0] = 0; scale_minor[1] = 2; scale_minor[2] = 3; scale_minor[3] = 5;
scale_minor[4] = 7; scale_minor[5] = 8; scale_minor[6] = 10;

// Dorian: W H W W W H W
scale_dorian = 20;
scale_dorian[0] = 0; scale_dorian[1] = 2; scale_dorian[2] = 3; scale_dorian[3] = 5;
scale_dorian[4] = 7; scale_dorian[5] = 9; scale_dorian[6] = 10;

// Chord degree offsets (scale degrees, 0-indexed)
// Major chords: I, IV, V (degrees 0, 3, 4)
// Minor chords: ii, iii, vi (degrees 1, 2, 5)
// Diminished: vii (degree 6)
chord_degrees = 100;
chord_degrees[0] = 0;  // I
chord_degrees[1] = 1;  // II
chord_degrees[2] = 2;  // III
chord_degrees[3] = 3;  // IV
chord_degrees[4] = 4;  // V
chord_degrees[5] = 5;  // VI
chord_degrees[6] = 6;  // VII
chord_degrees[7] = 0;  // i (minor)
chord_degrees[8] = 1;  // ii
chord_degrees[9] = 2;  // iii
chord_degrees[10] = 3; // iv
chord_degrees[11] = 4; // v

// Chord quality (0=major, 1=minor, 2=dim)
chord_quality = 120;
chord_quality[0] = 0; // I - major
chord_quality[1] = 1; // II - minor (ii in major key)
chord_quality[2] = 1; // III - minor (iii in major key)
chord_quality[3] = 0; // IV - major
chord_quality[4] = 0; // V - major
chord_quality[5] = 1; // VI - minor (vi in major key)
chord_quality[6] = 2; // VII - diminished (viiÂ° in major key)
chord_quality[7] = 1; // i - minor
chord_quality[8] = 1; // ii - minor
chord_quality[9] = 1; // iii - minor
chord_quality[10] = 1; // iv - minor
chord_quality[11] = 1; // v - minor

// Working arrays
current_scale = 200;      // 7 notes
current_chord_tones = 210; // up to 4 notes (root, 3rd, 5th, 7th)
available_notes = 220;    // all available MIDI notes with weights
note_weights = 300;       // parallel array of weights

last_note = -1;
current_note = -1;
note_playing = 0;
last_beat_pos = -1;
last_beat_num = -1;
samples_since_note = 0;
phrase_complete_waiting_beat = 0;  // Flag: phrase done, waiting for beat boundary to start rest

// Phrase generation state
phrase_active = 0;              // Are we currently in a phrase?
phrase_length = 0;              // Notes to generate in current phrase
phrase_note_count = 0;          // Notes generated so far
phrase_rest_count = 0;          // Rest beats between phrases
between_phrase_rest = 1;        // Beats of rest needed between phrases
between_phrase_rest_max = 0;    // Maximum rest counter to force phrase generation
phrase_start_note = -1;         // Starting note of phrase
phrase_end_note = -1;           // Ending note of phrase (planned)
phrase_direction = 0;           // -1 = down, 0 = neutral, 1 = up (for melodic momentum)
direction_steps = 0;            // How many notes we've moved in current direction
direction_change_countdown = 0; // Force direction change after N notes

// Prevent passing tone repeats within phrase
last_was_passing = 0;

// Pre-calculated phrase notes
phrase_notes = 700;  // Array of MIDI notes for this phrase

// Convert octave slider (0-5 = C1-C6) to MIDI base note
// C1 = MIDI 24, C2 = 36, C3 = 48, C4 = 60, C5 = 72, C6 = 84
function get_base_note() (
  (slider4 + 1) * 12 + 12;  // slider4=0 -> 24 (C1), slider4=3 -> 60 (C4)
);

// ============================================
// RANDOM NUMBER GENERATION
// ============================================

// Random seed - will be initialized on first block
rand_state = 1;
rand_calls = 0;
rand_initialized = 0;
rand_init_blocks = 0;       // Count blocks during initialization
phrase_build_counter = 0;  // Increments on each phrase build for entropy
last_endpoint_note = -1;   // Track last endpoint to avoid repeats
last_play_position = 0;    // Track play position for re-seeding detection

function seed_random() local(temp_seed, mix1, mix2, entropy1, entropy2) (
  // Accumulate entropy from multiple sources over time
  // Each call adds more entropy to rand_state
  
  // Get current time with microsecond precision
  entropy1 = floor(time_precise() * 1000000);
  
  // Add sample-based entropy (varies with audio buffer processing)
  entropy2 = (samplesblock * 104729) ^ (srate * 7919);
  
  // If this is initial seeding, use time as base
  // Otherwise, mix with existing state
  rand_init_blocks == 0 ? (
    temp_seed = entropy1 ^ entropy2;
  ) : (
    // Mix new entropy into existing state
    temp_seed = rand_state ^ entropy1 ^ entropy2 ^ (rand_init_blocks * 12345);
  );
  
  // Add playback position if available
  play_position > 0 ? (
    temp_seed = temp_seed ^ floor(play_position * 999983);
  );
  
  // Multiple rounds of mixing to ensure good distribution
  mix1 = temp_seed;
  mix1 = (mix1 ^ 61) ^ (mix1 >> 16);
  mix1 = mix1 + (mix1 << 3);
  mix1 = mix1 ^ (mix1 >> 4);
  mix1 = mix1 * 0x27d4eb2d;
  mix1 = mix1 ^ (mix1 >> 15);
  
  // Second round of mixing
  mix2 = mix1;
  mix2 = (mix2 ^ (mix2 >> 16)) * 0x7feb352d;
  mix2 = (mix2 ^ (mix2 >> 15)) * 0x846ca68b;
  mix2 = mix2 ^ (mix2 >> 16);
  
  // Ensure odd number for better PRNG behavior
  rand_state = (mix2 | 1);
  rand_init_blocks += 1;
  
  // Mark as fully initialized after collecting entropy from several blocks
  rand_init_blocks >= 5 ? rand_initialized = 1;
);

function my_rand() local(result) (
  // Re-seed every ~100 calls to prevent state cycling
  rand_calls = (rand_calls + 1) % 100;
  rand_calls == 0 ? (
    // Mix current state with fresh entropy from multiple sources
    rand_state = (rand_state ^ floor(time_precise() * 1000) ^ (phrase_build_counter * 7919) ^ (samplesblock * 31)) | 1;
  );
  
  rand_state = (rand_state * 1103515245 + 12345) & 0x7fffffff;
  result = rand_state / 0x7fffffff;
  
  // Validation: should always be 0-1
  (result < 0 || result > 1) ? (
    result = 0.5;  // Safe fallback
  );
  
  result;
);

// ============================================
// SCALE & CHORD FUNCTIONS
// ============================================

function get_scale_base() (
  slider2 == 0 ? scale_major :
  slider2 == 1 ? scale_minor :
  scale_dorian;
);

function build_scale() local(i, base, root) (
  root = slider1; // 0-11
  base = get_scale_base();
  i = 0;
  loop(7,
    current_scale[i] = (root + base[i]) % 12;
    i += 1;
  );
);

function build_chord_tones() local(degree, quality, root_idx, third_idx, fifth_idx, base) (
  degree = chord_degrees[slider3];
  quality = chord_quality[slider3];
  base = get_scale_base();

  // Root of chord (scale degree)
  current_chord_tones[0] = current_scale[degree];

  // Third (2 scale steps up)
  third_idx = (degree + 2) % 7;
  current_chord_tones[1] = current_scale[third_idx];

  // Fifth (4 scale steps up)
  fifth_idx = (degree + 4) % 7;
  current_chord_tones[2] = current_scale[fifth_idx];

  // Optional 7th (6 scale steps up)
  current_chord_tones[3] = current_scale[(degree + 6) % 7];
);

function is_chord_tone(note_class) local(i, found) (
  found = 0;
  i = 0;
  loop(3, // Check root, 3rd, 5th
    note_class == current_chord_tones[i] ? found = 1;
    i += 1;
  );
  found;
);

function is_scale_tone(note_class) local(i, found) (
  found = 0;
  i = 0;
  loop(7,
    note_class == current_scale[i] ? found = 1;
    i += 1;
  );
  found;
);

// Check how recently a note was played (returns 0-1, where 1 = most recent)
function get_recency_penalty(midi_note) local(i, pos, recency) (
  recency = 0;
  i = 0;
  loop(note_history_size,
    // Check from most recent backwards
    pos = (note_history_idx - 1 - i + note_history_size) % note_history_size;
    note_history[pos] == midi_note ? (
      // More recent = higher penalty. Position 0 (most recent) = 1.0, position 7 = 0.125
      recency = max(recency, 1 / (i + 1));
    );
    i += 1;
  );
  recency;
);

// Add note to history
function add_to_history(midi_note) (
  note_history[note_history_idx] = midi_note;
  note_history_idx = (note_history_idx + 1) % note_history_size;
);

// ============================================
// PHRASE GENERATION HELPERS
// ============================================

// Helper: Initialize phrase boundaries (hard and soft)
function init_phrase_boundaries() local(base_note, top_note) (
  base_note = get_base_note();
  top_note = base_note + (slider5 * 12);
  
  // Store in global temp variables
  temp_base_note = base_note;
  temp_top_note = top_note;
  temp_soft_base = base_note - SOFT_BOUNDARY_EXTENSION;
  temp_soft_top = top_note + SOFT_BOUNDARY_EXTENSION;
);

// Pick an ending note: weighted toward chord tones (95%), scale tones (4%), passing tones (1%)
function pick_phrase_endpoint() local(base_note, top_note, midi_note, note_class, weight, total_weight, random_val, cumulative, idx, selected, range) (
  base_note = get_base_note();
  top_note = base_note + (slider5 * 12);
  
  // Extend boundaries for soft limits
  soft_base = base_note - SOFT_BOUNDARY_EXTENSION;
  soft_top = top_note + SOFT_BOUNDARY_EXTENSION;

  num_available = 0;
  total_weight = 0;
  
  // Use loop instead of while for JSFX compatibility
  // Use soft boundaries for endpoint selection
  midi_note = soft_base;
  range = soft_top - soft_base + 1;
  idx = 0;
  loop(range,
    (midi_note <= soft_top) ? (
      note_class = midi_note % 12;
      weight = 0;
      
      is_chord_tone(note_class) ? (
        weight = CHORD_TONE_WEIGHT;
      ) : is_scale_tone(note_class) ? (
        weight = SCALE_TONE_WEIGHT;
      ) : (
        weight = PASSING_TONE_WEIGHT;
      );
      
      available_notes[num_available] = midi_note;
      note_weights[num_available] = weight;
      total_weight += weight;
      num_available += 1;
      midi_note += 1;
    );
    idx += 1;
  );
  
  // Normalize weights
  idx = 0;
  loop(num_available,
    note_weights[idx] = note_weights[idx] / total_weight;
    idx += 1;
  );
  
  // Weighted random selection
  random_val = my_rand();
  cumulative = 0;
  selected = available_notes[0];
  idx = 0;
  done = 0;
  loop(num_available,
    done ? (
      idx = num_available;  // Skip remaining iterations
    ) : (
      cumulative += note_weights[idx];
      random_val <= cumulative ? (
        selected = available_notes[idx];
        done = 1;
      );
      idx += 1;
    );
  );
  
  // Safety: if selected is still 0 or invalid, pick a random note from available
  (selected < soft_base || selected > soft_top) ? (
    selected = available_notes[floor(my_rand() * num_available)];
  );
  
  selected;
);

// Helper: Pick and validate endpoint, ensuring it's a chord tone
function pick_and_validate_endpoint() local(retry_count) (
  // Consume random values to break cycling patterns
  retry_count = 0;
  loop(5 + (phrase_build_counter % 7),
    my_rand();
    retry_count += 1;
  );
  
  // Pick ending note
  phrase_end_note = pick_phrase_endpoint();
  
  // Avoid repeating same endpoint consecutively
  retry_count = 0;
  loop(8,
    (phrase_end_note == last_endpoint_note) ? (
      phrase_end_note = pick_phrase_endpoint();
      retry_count += 1;
    ) : (
      retry_count = 10;  // break
    );
  );
  last_endpoint_note = phrase_end_note;
  
  // Ensure ending note is a chord tone - retry if not
  loop(10,
    !is_chord_tone(phrase_end_note % 12) ? (
      phrase_end_note = pick_phrase_endpoint();
    ) : (
      retry_count = 10;  // break
    );
  );
  
  // Return success if chord tone found
  is_chord_tone(phrase_end_note % 12);
);

// Helper: Determine phrase direction based on available room
function determine_phrase_direction() local(room_above, room_below, semitones_needed, direction, random_direction) (
  room_above = temp_top_note - phrase_end_note;
  room_below = phrase_end_note - temp_base_note;
  
  // Estimate semitones needed (roughly 2 per scale step)
  semitones_needed = phrase_length * 2;
  
  // Pick direction based on available room
  room_below >= semitones_needed ? (
    room_above >= semitones_needed ? (
      // Both directions work - pick randomly
      random_direction = my_rand();
      direction = random_direction < 0.5 ? 1 : -1;
    ) : (
      // Only room below - must go UP
      direction = 1;
    );
  ) : (
    // Not enough room below - must go DOWN
    direction = -1;
  );
  
  direction;
);

// Helper: Build temporary array of scale notes in extended range
function build_temp_scale_array() local(midi_note, note_class, temp_count) (
  temp_scale_notes = 800;
  temp_count = 0;
  
  // Fill with scale notes in extended range (soft boundaries)
  midi_note = temp_soft_base;
  loop(temp_soft_top - temp_soft_base + 1,
    note_class = midi_note % 12;
    is_scale_tone(note_class) ? (
      temp_scale_notes[temp_count] = midi_note;
      temp_count += 1;
    );
    midi_note += 1;
  );
  
  temp_count;  // Return count
);

// Helper: Find endpoint and start indices in scale array
function find_scale_indices(temp_count, direction) local(i, endpoint_idx, start_idx, steps_needed) (
  // Find endpoint index
  endpoint_idx = -1;
  i = 0;
  loop(temp_count,
    temp_scale_notes[i] == phrase_end_note ? endpoint_idx = i;
    i += 1;
  );
  
  // Store for return
  temp_endpoint_idx = endpoint_idx;
  
  endpoint_idx < 0 ? (
    // Failed to find endpoint
    temp_start_idx = -1;
    0;  // Return failure
  ) : (
    // Calculate start index
    steps_needed = floor(phrase_length * 1.5);
    
    direction > 0 ? (
      start_idx = max(0, endpoint_idx - steps_needed);
    ) : (
      start_idx = min(temp_count - 1, endpoint_idx + steps_needed);
    );
    
    temp_start_idx = start_idx;
    
    // Check validity
    (start_idx >= 0 && start_idx < temp_count) ? 1 : 0;
  );
);

// Helper: Build phrase notes with passing tones, repeats, and direction changes
function build_phrase_notes(direction, temp_count) local(i, note_idx, current_direction, steps_since_dir_change, prev_midi_note, prev_note_type, build_failed, midi_note, note_class, curr_note_type, use_repeat, passing_candidate, passing_class, distance_from_top, distance_from_bottom, near_top_boundary, near_bottom_boundary, min_steps_between, dir_change_prob, skip_amount, passed_endpoint, overshoot_limit, endpoint_overshoot) (
  // Note generation probabilities
  passing_tone_prob = slider8 == 1 ? PASSING_TONE_PROB_ENABLED : 0;
  repeat_chord_prob = REPEAT_CHORD_PROB;
  repeat_scale_prob = REPEAT_SCALE_PROB;
  repeat_passing_prob = REPEAT_PASSING_PROB;
  
  // For longer phrases, allow overshooting the endpoint and returning
  // Shorter phrases (<=8 notes): no overshoot
  // Medium phrases (9-14): modest overshoot
  // Long phrases (15+): significant overshoot
  endpoint_overshoot = 0;
  phrase_length <= 8 ? (
    endpoint_overshoot = 0;
  ) : phrase_length <= 14 ? (
    endpoint_overshoot = 2 + floor(my_rand() * 2);
  ) : (
    endpoint_overshoot = 3 + floor(my_rand() * 3);
  );
  
  // Initialize build state
  phrase_note_count = 0;
  i = 0;
  build_failed = 0;
  prev_midi_note = -1;
  prev_note_type = 0;
  note_idx = temp_start_idx;
  current_direction = direction;
  steps_since_dir_change = 99;
  passed_endpoint = 0;
  overshoot_limit = temp_endpoint_idx + (direction > 0 ? endpoint_overshoot : -endpoint_overshoot);
  
  loop(phrase_length,
    build_failed == 0 ? (
      // Check bounds
      (note_idx < 0 || note_idx >= temp_count) ? (
        build_failed = 1;
        phrase_note_count = -1;
      ) : (
        // Consider direction change (not on first or last note)
        (i > 0 && i < phrase_length - 1) ? (
          // Get current note for boundary check
          midi_note = temp_scale_notes[note_idx];
          
          // Check proximity to boundaries
          distance_from_top = temp_soft_top - midi_note;
          distance_from_bottom = midi_note - temp_soft_base;
          
          near_top_boundary = distance_from_top <= 3;
          near_bottom_boundary = distance_from_bottom <= 3;
          
          // Force direction change if at boundary
          near_top_boundary ? (
            current_direction > 0 ? (
              current_direction = -1;
              steps_since_dir_change = 0;
            );
          );
          near_bottom_boundary ? (
            current_direction < 0 ? (
              current_direction = 1;
              steps_since_dir_change = 0;
            );
          );
          
          // Check if we've passed the overshoot limit - force turnaround
          passed_endpoint == 0 && endpoint_overshoot > 0 ? (
            direction > 0 ? (
              note_idx >= overshoot_limit ? (
                passed_endpoint = 1;
                current_direction = -1;
                steps_since_dir_change = 0;
              );
            ) : (
              note_idx <= overshoot_limit ? (
                passed_endpoint = 1;
                current_direction = 1;
                steps_since_dir_change = 0;
              );
            );
          );
          
          // Normal direction change logic
          !near_top_boundary && !near_bottom_boundary && passed_endpoint == 0 ? (
            phrase_length <= 8 ? (
              min_steps_between = 4 + floor(my_rand() * 3);
              dir_change_prob = 0.2;
            ) : phrase_length <= 14 ? (
              min_steps_between = 3 + floor(my_rand() * 2);
              dir_change_prob = 0.3;
            ) : (
              min_steps_between = 2 + floor(my_rand() * 2);
              dir_change_prob = 0.4;
            );
            
            (steps_since_dir_change >= min_steps_between) ? (
              my_rand() < dir_change_prob ? (
                current_direction = -current_direction;
                steps_since_dir_change = 0;
              );
            );
          );
        );
        
        // Get the base scale note
        midi_note = temp_scale_notes[note_idx];
        note_class = midi_note % 12;
        
        // Determine note type
        curr_note_type = is_chord_tone(note_class) ? 1 : 2;
        
        // Check for repeat
        use_repeat = 0;
        (i > 0 && i < phrase_length - 1 && prev_midi_note > 0) ? (
          prev_note_type == 1 ? (
            my_rand() < repeat_chord_prob ? use_repeat = 1;
          ) : prev_note_type == 2 ? (
            my_rand() < repeat_scale_prob ? use_repeat = 1;
          ) : prev_note_type == 3 ? (
            my_rand() < repeat_passing_prob ? use_repeat = 1;
          );
        );
        
        use_repeat ? (
          midi_note = prev_midi_note;
          curr_note_type = prev_note_type;
        ) : (
          // Check for passing tone
          (i > 0 && i < phrase_length - 1) ? (
            my_rand() < passing_tone_prob ? (
              passing_candidate = direction > 0 ? midi_note - 1 : midi_note + 1;
              passing_class = passing_candidate % 12;
              (!is_scale_tone(passing_class) && passing_candidate >= temp_soft_base && passing_candidate <= temp_soft_top) ? (
                midi_note = passing_candidate;
                curr_note_type = 3;
              );
            );
          );
        );
        
        // Check soft bounds
        (midi_note < temp_soft_base || midi_note > temp_soft_top) ? (
          build_failed = 1;
          phrase_note_count = -1;
        ) : (
          phrase_notes[i] = midi_note;
          prev_midi_note = midi_note;
          prev_note_type = curr_note_type;
          i += 1;
          steps_since_dir_change += 1;
          
          // Advance note_idx
          skip_amount = floor(my_rand() * 2) + 1;
          current_direction > 0 ? (
            note_idx += skip_amount;
          ) : (
            note_idx -= skip_amount;
          );
        );
      );
    );
  );
  
  // Return success/failure
  phrase_note_count >= 0 ? 1 : 0;
);

// Build entire phrase by walking scale from calculated start to pre-selected end
function build_phrase_from_endpoint() local(max_phrase, min_phrase, direction, temp_count, success) (
  phrase_build_counter += 1;
  
  // Step 1: Initialize boundaries
  init_phrase_boundaries();
  
  // Step 2: Pick and validate endpoint
  pick_and_validate_endpoint() ? (
    // Endpoint is valid chord tone, continue
    
    // Step 3: Determine phrase length
    max_phrase = min(slider7, slider5 * 7);
    min_phrase = min(slider6, max_phrase);
    random_length = my_rand();
    phrase_length = min_phrase + floor(random_length * (max_phrase - min_phrase + 1));
    
    // Step 4: Determine direction
    direction = determine_phrase_direction();
    phrase_direction = direction;
    
    // Step 5: Build temp scale array
    temp_count = build_temp_scale_array();
    
    // Step 6: Find scale indices
    find_scale_indices(temp_count, direction) ? (
      // Valid indices found
      
      // Step 7: Build phrase notes
      success = build_phrase_notes(direction, temp_count);
      
      // Step 8: Finalize
      success ? (
        phrase_active = 1;
        phrase_note_count = 0;
        last_note = -1;
      ) : (
        // Build failed - out of bounds
        phrase_active = 0;
        between_phrase_rest = 1;
      );
    ) : (
      // Failed to find valid indices
      phrase_active = 0;
      between_phrase_rest = 1;
      phrase_note_count = -1;
    );
  ) : (
    // Failed to find chord tone endpoint
    phrase_active = 0;
    between_phrase_rest = 1;
  );
);

// ============================================
// MIDI OUTPUT FUNCTIONS
// ============================================

function send_note_on(note, vel) (
  midisend(0, $x90 + (slider14 > 0 ? slider14 - 1 : 0), note, vel);
  note_playing = note;
);

function send_note_off() (
  note_playing > 0 ? (
    midisend(0, $x80 + (slider14 > 0 ? slider14 - 1 : 0), note_playing, 0);
    note_playing = 0;
  );
);

@slider
build_scale();
build_chord_tones();

@block
// Seed random - collect entropy over first several blocks for better randomization
// This helps ensure different seeds on each plugin instance
rand_initialized == 0 ? (
  seed_random();
) : (
  // Check if we should re-seed (e.g., user stopped and restarted playback)
  abs(play_position - last_play_position) > 10 ? (
    rand_init_blocks = 0;  // Reset to re-accumulate entropy
    rand_initialized = 0;
    seed_random();
  );
  last_play_position = play_position;
);

slider12 == 1 ? ( // Generation enabled
  // Get current beat position (quarter notes)
  beat_num = floor(beat_position);
  beat_pos = floor(beat_position * 4) / 4; // Quantize to 16th notes
  
  // Check if we've crossed a beat boundary (quarter note)
  beat_num != last_beat_num ? (
    last_beat_num = beat_num;
    
    // If phrase was complete and waiting for beat boundary, now start rest
    phrase_complete_waiting_beat ? (
      phrase_complete_waiting_beat = 0;
      // Rest between phrases controlled by density
      // At density 0.1 (sparse): 4-8 beats rest
      // At density 1.0 (busy): 1-2 beats rest
      max_rest = floor(8 - slider9 * 6);  // 8 at 0.1, 2 at 1.0
      min_rest = floor(4 - slider9 * 3);  // 4 at 0.1, 1 at 1.0
      min_rest = max(1, min_rest);
      between_phrase_rest = min_rest + floor(my_rand() * (max_rest - min_rest + 1));
      send_note_off();
    );
  );

  beat_pos != last_beat_pos ? (
    last_beat_pos = beat_pos;

    // Handle between-phrase rest
    between_phrase_rest > 0 ? (
      between_phrase_rest_max += 1;
      between_phrase_rest -= 1;
      between_phrase_rest == 0 ? (
        // Rest complete, build new phrase
        build_phrase_from_endpoint();
        between_phrase_rest_max = 0;
      );
      // Safety: if rest has gone on too long (>2 beats), force generation
      (between_phrase_rest_max > 2) ? (
        between_phrase_rest = 0;
        build_phrase_from_endpoint();
        between_phrase_rest_max = 0;
      );
      send_note_off();
    ) : phrase_active ? (
      // We're in a phrase - play pre-calculated notes
      phrase_note_count < phrase_length ? (
        // Rest probability within phrase: higher density = fewer rests
        // At density 0.1 (sparse): 60% rest chance
        // At density 1.0 (busy): 0% rest chance
        inner_rest_prob = 0.6 * (1 - slider9);
        (phrase_note_count > 0 && my_rand() < inner_rest_prob) ? (
          send_note_off();
        ) : (
          send_note_off();

          // Play the next note from pre-calculated phrase
          new_note = phrase_notes[phrase_note_count];
          
          // Calculate velocity based on melodic direction and position
          velocity = slider10 + (slider11 - slider10) / 2;  // Start at midpoint
          
          // If we have a previous note, adjust velocity by direction
          last_note >= 0 ? (
            note_diff = new_note - last_note;
            // Going up: boost velocity toward max
            note_diff > 0 ? (
              velocity = slider10 + (slider11 - slider10) * 0.6 + my_rand() * (slider11 - slider10) * 0.2;
            ) : note_diff < 0 ? (
              // Going down: reduce velocity toward min
              velocity = slider10 + (slider11 - slider10) * 0.3 + my_rand() * (slider11 - slider10) * 0.2;
            ) : (
              // Same note: midpoint with randomness
              velocity = slider10 + (slider11 - slider10) * 0.45 + my_rand() * (slider11 - slider10) * 0.1;
            );
          ) : (
            // First note: randomize within range
            velocity = slider10 + my_rand() * (slider11 - slider10);
          );
          
          // Clamp to valid MIDI velocity range
          velocity = max(1, min(127, floor(velocity)));
          
          // Check if this note should be an 8th note (based on slider13)
          is_eighth_note = my_rand() < slider13;
          
          // Play note at beat (8th notes play immediately, no swing)
          send_note_on(new_note, velocity);
          last_note = new_note;
          phrase_note_count += 1;
        );
      ) : (
        // Phrase complete - wait for beat boundary before transitioning to rest
        phrase_active = 0;
        phrase_direction = 0;
        phrase_complete_waiting_beat = 1;
        send_note_off();
      );
    ) : (
      // Not in phrase and no rest pending - start a phrase (always, not randomly)
      build_phrase_from_endpoint();
    );
  );
);

// Pass through incoming MIDI
while(midirecv(offset, msg1, msg2, msg3)) (
  midisend(offset, msg1, msg2, msg3);
);
