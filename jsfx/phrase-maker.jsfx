version: 1.0.1
desc: Phrase Maker
author: Saurav Plays Piano
about:
  # Phrase Maker
  A basic generative phrase engine that tries to create melodic phrases based on musical theory.

// Phrase Maker
// Copyright (c) 2026 Saurav Plays Piano
// Licensed under the MIT License

// === MUSICAL SETTINGS ===
slider1:0<0,11,1{C,C#,D,D#,E,F,F#,G,G#,A,A#,B}>Root Note
slider2:0<0,2,1{Major (bright happy),Minor (dark sad),Dorian (jazzy bittersweet)}>Scale
slider3:0<0,5,1{I,ii,iii,IV,V,vi}>Current Chord (Roman Numeral)

// === RANGE SETTINGS ===
slider4:3<0,5,1{C1,C2,C3,C4,C5,C6}>Base Octave
slider5:2<1,4,1>Octave Range

// === PHRASE SETTINGS ===
slider6:6<2,12,1>Min Phrase Length
slider7:16<3,24,1>Max Phrase Length
// slider8:1<0,1,{Off,On}>Use Passing Tones
slider9:0.75<0,1,0.05>Density (sparse to busy)
slider13:0.25<0,1,0.05>8th Note Amount

// === PERFORMANCE ===
slider10:40<1,127,1>Min Velocity
slider11:80<1,127,1>Max Velocity

// === PROGRESSION SEQUENCER ===
slider15:1<0,1,{Off,Auto-Loop}>Progression Mode
slider16:4<1,8,1>Loop Length (# of chords)
slider17:0<0,5,1{I,ii,iii,IV,V,vi}>Prog Chord 1
slider18:4<0,5,1{I,ii,iii,IV,V,vi}>Prog Chord 2
slider19:5<0,5,1{I,ii,iii,IV,V,vi}>Prog Chord 3
slider20:3<0,5,1{I,ii,iii,IV,V,vi}>Prog Chord 4
slider21:4<1,8,1>Measures Per Chord

// === SYSTEM ===
slider12:1<0,1,{Off,On}>Enable Generation
slider14:0<0,127,1>MIDI Channel (0=all)

in_pin:none
out_pin:none

@init
// ============================================
// CONSTANTS
// ============================================

// Weight constants for note selection
CHORD_ROOT_WEIGHT = 60;   // Root of chord - strongest
CHORD_FIFTH_WEIGHT = 25;  // Perfect 5th - strong
CHORD_THIRD_WEIGHT = 10;  // Major/minor 3rd - moderate
SCALE_TONE_WEIGHT = 4;    // Non-chord scale degrees
PASSING_TONE_WEIGHT = 1;  // Chromatic passing tones

// Probability constants
PASSING_TONE_PROB_ENABLED = 0.12;  // Chance to insert chromatic passing tone
REPEAT_CHORD_PROB = 0.15;          // Chance to repeat previous chord tone
REPEAT_SCALE_PROB = 0.08;          // Chance to repeat previous scale tone
REPEAT_PASSING_PROB = 0.03;        // Chance to repeat previous passing tone
INNER_REST_BASE = 0.6;             // Base inner rest probability scale at low density

// Phrase movement constants (controls note-to-note stepping behavior)
MAX_JUMP = 4;  // Maximum scale notes to jump; longer jumps have lower probability

// Phase balance constants (controls exploration vs resolution)
EXPLORATION_RATIO = 0.65;          // Fraction of phrase spent exploring (0.5-0.8)
RESOLUTION_START_DISTANCE = 6;     // Start resolving when within N scale steps of target
RESOLUTION_STEP_BIAS = 0.5;        // Probability of stepping toward target in resolution (0.5-1.0) - lowered to allow more wandering
APPROACH_FROM_BELOW_PROB = 0.6;    // Probability of approaching final note from below
MAX_CONSECUTIVE_REPEATS = 2;       // Maximum times a note can repeat consecutively
MAX_CONSECUTIVE_SKIPS = 1;         // Maximum consecutive large intervals (>=2 scale steps) - set to 1 to prevent arpeggio patterns
CHORD_BOUNDARY_RESPECT_PROB = 0.8; // Probability of ending phrase near chord boundary (0.8 = 80% respect, 20% overshoot)
DOWNBEAT_END_BIAS = 0.65;          // Probability to snap phrase end to nearest measure downbeat when close
DOWNBEAT_SNAP_WINDOW = 1.0;        // Max distance (in beats) from a downbeat to allow snapping
DOWNBEAT_REST_BONUS = 2;           // Extra quarter notes of rest when phrase ends on downbeat
SOFT_BOUNDARY_EXTENSION = 2;       // Semitones to extend beyond octave range for smooth voice leading

// Rest behavior constants (controls between-phrase rest lengths)
// These are in quarter notes (decremented once per beat_num change)
REST_MAX_BASE = 4;      // Base max rest at low density
REST_MIN_BASE = 2;      // Base min rest at low density
REST_MIN_FLOOR = 1;     // Absolute minimum rest
REST_MAX_CEILING = 8;   // Maximum allowed rest

// ============================================
// MEMORY LAYOUT - SCALE DEFINITIONS
// ============================================

// Scale intervals (semitones from root)
// Major: W W H W W W H
scale_major = 0; // Array index
scale_major[0] = 0; scale_major[1] = 2; scale_major[2] = 4; scale_major[3] = 5;
scale_major[4] = 7; scale_major[5] = 9; scale_major[6] = 11;

// Minor: W H W W H W W
scale_minor = 10;
scale_minor[0] = 0; scale_minor[1] = 2; scale_minor[2] = 3; scale_minor[3] = 5;
scale_minor[4] = 7; scale_minor[5] = 8; scale_minor[6] = 10;

// Dorian: W H W W W H W
scale_dorian = 20;
scale_dorian[0] = 0; scale_dorian[1] = 2; scale_dorian[2] = 3; scale_dorian[3] = 5;
scale_dorian[4] = 7; scale_dorian[5] = 9; scale_dorian[6] = 10;

// Chord degree offsets (scale degrees, 0-indexed)
// I (0), ii (1), iii (2), IV (3), V (4), vi (5)
chord_degrees = 100;
chord_degrees[0] = 0;  // I
chord_degrees[1] = 1;  // ii
chord_degrees[2] = 2;  // iii
chord_degrees[3] = 3;  // IV
chord_degrees[4] = 4;  // V
chord_degrees[5] = 5;  // vi

// Chord quality (0=major, 1=minor, 2=dim)
chord_quality = 120;
chord_quality[0] = 0; // I - major
chord_quality[1] = 1; // ii - minor
chord_quality[2] = 1; // iii - minor
chord_quality[3] = 0; // IV - major
chord_quality[4] = 0; // V - major
chord_quality[5] = 1; // vi - minor

// Working arrays
current_scale = 200;      // 7 notes
current_chord_tones = 210; // up to 4 notes (root, 3rd, 5th, 7th)
available_notes = 220;    // all available MIDI notes with weights
note_weights = 300;       // parallel array of weights

// Playback state
note_playing = 0;
last_eighth = -1;  // Last 8th-note boundary processed

// Phrase generation state
phrase_active = 0;              // Are we currently in a phrase?
phrase_length = 0;              // Notes to generate in current phrase (for build phase)
between_phrase_rest = 0;        // Quarter notes of rest before next phrase
phrase_end_note = -1;           // Ending note of phrase (planned)
phrase_direction = 0;           // -1 = down, 0 = neutral, 1 = up (for melodic momentum)

// Pre-calculated phrase data (step sequencer model)
// Each index = one 8th note slot. 0 = rest/silence at that slot.
phrase_events = 700;      // MIDI note at each 8th-note slot (0 = rest)
phrase_velocities = 780;  // Velocity for each slot
phrase_slot_count = 0;    // Total 8th-note slots in this phrase
phrase_slot_index = 0;    // Current playback position
phrase_rest_after = 0;    // Quarter notes of rest after this phrase
phrase_start_beat = 0;    // Beat position when phrase started
phrase_start_eighth = 0;  // 8th note counter when phrase started
phrase_built_for_chord = -1; // Which chord (slider3 value) this phrase was created for

// Legacy array for note generation (before scheduling)
phrase_notes = 860;       // Temporary: raw MIDI notes before timing applied

// Track last endpoint to avoid repeats
last_endpoint_note = -1;

// Background generation state
// Progression sequencer state
prog_chord_index = 0;         // Current chord in the progression (0-7)
prog_beat_counter = 0;        // Beats elapsed in current chord
prog_last_beat_num = -1;      // Track beat changes (-1 = uninitialized)
prog_chords = 900;            // Array to store the progression sequence
prog_current_chord = -1;      // Currently active chord (-1 = uninitialized)
prog_beats_until_change = 0;  // Beats remaining until next chord change
last_beat_position = -1;      // Track playback position for seek/loop detection

// ============================================
// SCALE & CHORD FUNCTIONS
// ============================================

function get_scale_base() (
  slider2 == 0 ? scale_major :
  slider2 == 1 ? scale_minor :
  scale_dorian;
);

function build_scale() local(i, base, root) (
  root = slider1; // 0-11
  base = get_scale_base();
  i = 0;
  loop(7,
    current_scale[i] = (root + base[i]) % 12;
    i += 1;
  );
);

function build_chord_tones() local(degree, quality, root_idx, third_idx, fifth_idx, base) (
  degree = chord_degrees[slider3];
  quality = chord_quality[slider3];
  base = get_scale_base();

  // Root of chord (scale degree)
  current_chord_tones[0] = current_scale[degree];

  // Third (2 scale steps up)
  third_idx = (degree + 2) % 7;
  current_chord_tones[1] = current_scale[third_idx];

  // Fifth (4 scale steps up)
  fifth_idx = (degree + 4) % 7;
  current_chord_tones[2] = current_scale[fifth_idx];

  // Optional 7th (6 scale steps up)
  current_chord_tones[3] = current_scale[(degree + 6) % 7];
);

// Render a note name (C, C#, etc) without octave
function gfx_print_note_class(note_val) (
  note_val = note_val % 12;
  note_val == 0 ? gfx_printf("C") :
  note_val == 1 ? gfx_printf("C#") :
  note_val == 2 ? gfx_printf("D") :
  note_val == 3 ? gfx_printf("D#") :
  note_val == 4 ? gfx_printf("E") :
  note_val == 5 ? gfx_printf("F") :
  note_val == 6 ? gfx_printf("F#") :
  note_val == 7 ? gfx_printf("G") :
  note_val == 8 ? gfx_printf("G#") :
  note_val == 9 ? gfx_printf("A") :
  note_val == 10 ? gfx_printf("A#") :
  gfx_printf("B");
);

// Render a chord name (e.g. C, Am, G#dim)
function gfx_print_chord_name(chord_idx) local(degree, root_note, third_note, fifth_note, interval_third, interval_fifth) (
  chord_idx < 0 ? (
    gfx_printf("--");
  ) : (
    degree = chord_degrees[chord_idx];
    
    // Get notes from current scale
    root_note = current_scale[degree];
    third_note = current_scale[(degree + 2) % 7];
    fifth_note = current_scale[(degree + 4) % 7];
    
    // Calculate intervals
    interval_third = (third_note - root_note + 12) % 12;
    interval_fifth = (fifth_note - root_note + 12) % 12;
    
    // Print Root
    gfx_print_note_class(root_note);
    
    // Print Quality
    interval_third == 3 ? (
      interval_fifth == 6 ? gfx_printf("dim") : gfx_printf("m");
    ) : (
      interval_fifth == 8 ? gfx_printf("aug");
    );
  );
);

// Render a MIDI note name with octave (C-1 = 0). Uses short names for HUD.
function gfx_print_note_name(midi_note) local(note_class, octave) (
  midi_note <= 0 ? (
    gfx_printf("--");
  ) : (
    note_class = midi_note % 12;
    octave = floor(midi_note / 12) - 1;  // MIDI 60 -> octave 4
    note_class == 0  ? gfx_printf("C%d", octave) :
    note_class == 1  ? gfx_printf("C#%d", octave) :
    note_class == 2  ? gfx_printf("D%d", octave) :
    note_class == 3  ? gfx_printf("D#%d", octave) :
    note_class == 4  ? gfx_printf("E%d", octave) :
    note_class == 5  ? gfx_printf("F%d", octave) :
    note_class == 6  ? gfx_printf("F#%d", octave) :
    note_class == 7  ? gfx_printf("G%d", octave) :
    note_class == 8  ? gfx_printf("G#%d", octave) :
    note_class == 9  ? gfx_printf("A%d", octave) :
    note_class == 10 ? gfx_printf("A#%d", octave) : gfx_printf("B%d", octave);
  );
);

function is_chord_tone(note_class) local(i, found) (
  found = 0;
  i = 0;
  loop(3, // Check root, 3rd, 5th
    note_class == current_chord_tones[i] ? found = 1;
    i += 1;
  );
  found;
);

// Get the weight for a note based on its chord role
function get_chord_tone_weight(note_class) local(i, weight) (
  weight = 0;
  i = 0;
  loop(3,
    note_class == current_chord_tones[i] ? (
      i == 0 ? weight = CHORD_ROOT_WEIGHT :   // Root
      i == 1 ? weight = CHORD_THIRD_WEIGHT :  // 3rd
      weight = CHORD_FIFTH_WEIGHT;            // 5th
    );
    i += 1;
  );
  weight;
);

function is_scale_tone(note_class) local(i, found) (
  found = 0;
  i = 0;
  loop(7,
    note_class == current_scale[i] ? found = 1;
    i += 1;
  );
  found;
);

// Unified note selection weight: chord tones > scale tones > passing tones
function get_note_selection_weight(midi_note) local(note_class, weight) (
  note_class = midi_note % 12;
  weight = 0;
  is_chord_tone(note_class) ? (
    weight = get_chord_tone_weight(note_class);
  ) : is_scale_tone(note_class) ? (
    weight = SCALE_TONE_WEIGHT;
  ) : (
    weight = PASSING_TONE_WEIGHT;
  );
  weight;
);

// Check how recently a note was played (returns 0-1, where 1 = most recent)
function get_recency_penalty(midi_note) local(i, pos, recency) (
  recency = 0;
  i = 0;
  loop(note_history_size,
    // Check from most recent backwards
    pos = (note_history_idx - 1 - i + note_history_size) % note_history_size;
    note_history[pos] == midi_note ? (
      // More recent = higher penalty. Position 0 (most recent) = 1.0, position 7 = 0.125
      recency = max(recency, 1 / (i + 1));
    );
    i += 1;
  );
  recency;
);

// Add note to history
function add_to_history(midi_note) (
  note_history[note_history_idx] = midi_note;
  note_history_idx = (note_history_idx + 1) % note_history_size;
);

// ============================================
// PHRASE SCHEDULING (convert notes to timed events)
// ============================================

// Schedule phrase_notes into phrase_events timeline
// Applies timing (8th notes), inner rests, and calculates velocities
function schedule_phrase_events() local(i, slot, note, prev_note, note_diff,
    density, eighth_prob, inner_rest_prob, rest_scale, base_inner_rest,
    rest_weight, rest_multiplier, rest_emphasis, velocity, vel_range,
    sparse_boost, min_rest, max_rest) (

  // Clear the events array
  slot = 0;
  loop(64,
    phrase_events[slot] = 0;
    phrase_velocities[slot] = 0;
    slot += 1;
  );

  // Get parameters
  density = max(0, min(1, slider9));
  eighth_prob = slider13;
  vel_range = slider11 - slider10;

  // Calculate inner rest probability (same formula as before)
  rest_scale = 1 - density;
  base_inner_rest = INNER_REST_BASE * rest_scale * sqrt(rest_scale) * 1.6;
  base_inner_rest = min(1, base_inner_rest);

  // Schedule each note
  slot = 0;
  prev_note = -1;
  i = 0;
  max_slot_used = 0;
  loop(phrase_length,
    note = phrase_notes[i];

    // Place this note at current slot (all notes play)
    phrase_events[slot] = note;
    max_slot_used = max(max_slot_used, slot);

    // Calculate velocity based on melodic direction
    prev_note >= 0 ? (
      note_diff = note - prev_note;
      note_diff > 0 ? (
        // Upward phrase: increase velocity incrementally
        velocity = phrase_velocities[slot - 1] + 3 + rand() * 2;
        velocity = max(slider10, min(slider11, velocity));
      ) : note_diff < 0 ? (
        // Downward phrase: decrease velocity incrementally
        velocity = phrase_velocities[slot - 1] - 3 - rand() * 2;
        velocity = max(slider10, min(slider11, velocity));
      ) : (
        // Repeated note: maintain velocity with slight variation
        velocity = phrase_velocities[slot - 1] + (rand() * 4 - 2);
        velocity = max(slider10, min(slider11, velocity));
      );
    ) : (
      velocity = slider10 + rand() * vel_range;
    );
    phrase_velocities[slot] = max(1, min(127, floor(velocity)));

    prev_note = note;

    // Calculate rest duration AFTER this note based on its importance
    // Important notes (root/5th/3rd) get longer rests after them
    rest_weight = get_note_selection_weight(note);
    rest_multiplier = rest_weight / CHORD_ROOT_WEIGHT;
    rest_emphasis = 0.5 + rest_multiplier * 1.5;  // Root=2.0, Fifth=1.125, Third=0.75, Scale=0.6, Passing=0.525

    // Decide timing for next note based on note importance and density
    (i < phrase_length - 1) ? (
      // Higher rest_emphasis = longer gap after this note
      rand() < (eighth_prob * (1.0 / rest_emphasis)) ? (
        // Next note comes as 8th note (next slot) - less likely for important notes
        slot += 1;
      ) : (
        // Next note on quarter boundary (skip to even slot)
        slot += 1;
        (slot % 2 == 1) ? slot += 1;  // Ensure even slot for quarter note
        
        // For very important notes (root/fifth), add extra gap at sparse densities
        (rest_emphasis > 1.5 && density < 0.5 && rand() < (rest_emphasis - 1.0)) ? (
          slot += 2;  // Add full quarter note of extra space
        );
      );
    );

    i += 1;
  );

  // Record total slots used (count = highest slot index + 1)
  phrase_slot_count = max_slot_used + 1;

  // Calculate rest after this phrase (in 8th notes since countdown is now per-8th)
  rest_scale = 1 - density;
  sparse_boost = 1 + rest_scale * 1.5;
  min_rest = ceil(REST_MIN_BASE * sparse_boost * 2);  // Convert to 8ths
  max_rest = ceil(REST_MAX_BASE * sparse_boost * 2);  // Convert to 8ths
  min_rest = max(REST_MIN_FLOOR * 2, min_rest);
  max_rest = min(REST_MAX_CEILING * 2, max_rest);
  max_rest = max(min_rest, max_rest);
  phrase_rest_after = min_rest + floor(rand() * (max_rest - min_rest + 1));
);

// Nudge the final note toward the nearest measure downbeat when close (bias, not absolute)
function bias_phrase_end_to_downbeat() local(i, last_slot, slot_idx, note, vel,
    chord_pos_beats, phrase_end_rel_beats, target_abs_beats, nearest_downbeat,
    diff_beats, desired_rel_beats, desired_slot) (

  (slider15 == 1) ? (
    // Find last occupied slot (highest index with a note)
    last_slot = -1;
    i = 0;
    loop(64,
      slot_idx = 63 - i;
      phrase_events[slot_idx] > 0 ? last_slot = (last_slot < 0 ? slot_idx : last_slot);
      i += 1;
    );

    (last_slot >= 0) ? (
      // Use current chord position for live phrases; start-of-chord for background build
      chord_pos_beats = prog_beat_counter;
      phrase_end_rel_beats = last_slot * 0.5;  // slots are 8ths
      target_abs_beats = chord_pos_beats + phrase_end_rel_beats;

      // Nearest measure downbeat (every 4 beats)
      nearest_downbeat = floor((target_abs_beats / 4) + 0.5) * 4;
      diff_beats = abs(target_abs_beats - nearest_downbeat);

      (diff_beats <= DOWNBEAT_SNAP_WINDOW && rand() < DOWNBEAT_END_BIAS) ? (
        desired_rel_beats = nearest_downbeat - chord_pos_beats;
        desired_slot = floor(desired_rel_beats * 2 + 0.5);
        desired_slot = max(0, min(63, desired_slot));

        (desired_slot != last_slot) ? (
          note = phrase_events[last_slot];
          vel = phrase_velocities[last_slot];
          phrase_events[last_slot] = 0;
          phrase_velocities[last_slot] = 0;
          phrase_events[desired_slot] = note;
          phrase_velocities[desired_slot] = vel;
          phrase_slot_count = max(phrase_slot_count, desired_slot + 1);
          // Increase rest after phrase to emphasize the downbeat landing
          phrase_rest_after += DOWNBEAT_REST_BONUS;
        );
      );
    );
  );
);

// Convert octave slider (0-5 = C1-C6) to MIDI base note
// C1 = MIDI 24, C2 = 36, C3 = 48, C4 = 60, C5 = 72, C6 = 84
function get_base_note() (
  (slider4 + 1) * 12 + 12;  // slider4=0 -> 24 (C1), slider4=3 -> 60 (C4)
);

// ============================================
// PHRASE GENERATION HELPERS
// ============================================

// Helper: Initialize phrase boundaries (hard and soft)
function init_phrase_boundaries() local(base_note, top_note) (
  base_note = get_base_note();
  top_note = base_note + (slider5 * 12);
  
  // Store in global temp variables
  temp_base_note = base_note;
  temp_top_note = top_note;
  temp_soft_base = base_note - SOFT_BOUNDARY_EXTENSION;
  temp_soft_top = top_note + SOFT_BOUNDARY_EXTENSION;
);

// Pick an ending note: weighted toward chord tones (95%), scale tones (4%), passing tones (1%)
function pick_phrase_endpoint() local(base_note, top_note, midi_note, note_class, weight, total_weight, random_val, cumulative, idx, selected, range) (
  base_note = get_base_note();
  top_note = base_note + (slider5 * 12);
  
  // Extend boundaries for soft limits
  soft_base = base_note - SOFT_BOUNDARY_EXTENSION;
  soft_top = top_note + SOFT_BOUNDARY_EXTENSION;

  num_available = 0;
  total_weight = 0;
  
  // Use loop instead of while for JSFX compatibility
  // Use soft boundaries for endpoint selection
  midi_note = soft_base;
  range = soft_top - soft_base + 1;
  idx = 0;
  loop(range,
    (midi_note <= soft_top) ? (
      // Compute selection weight for this MIDI note
      weight = get_note_selection_weight(midi_note);
      
      available_notes[num_available] = midi_note;
      note_weights[num_available] = weight;
      total_weight += weight;
      num_available += 1;
      midi_note += 1;
    );
    idx += 1;
  );
  
  // Normalize weights
  idx = 0;
  loop(num_available,
    note_weights[idx] = note_weights[idx] / total_weight;
    idx += 1;
  );
  
  // Weighted random selection
  random_val = rand();
  cumulative = 0;
  selected = available_notes[0];
  idx = 0;
  done = 0;
  loop(num_available,
    done ? (
      idx = num_available;  // Skip remaining iterations
    ) : (
      cumulative += note_weights[idx];
      random_val <= cumulative ? (
        selected = available_notes[idx];
        done = 1;
      );
      idx += 1;
    );
  );
  
  // Safety: if selected is still 0 or invalid, pick a random note from available
  (selected < soft_base || selected > soft_top) ? (
    selected = available_notes[floor(rand() * num_available)];
  );
  
  selected;
);

// Helper: Pick and validate endpoint, ensuring it's a chord tone
function pick_and_validate_endpoint() local(retry_count) (
  // Consume random values to break cycling patterns
  retry_count = 0;
  loop(5 + (phrase_build_counter % 7),
    rand();
    retry_count += 1;
  );
  
  // Pick ending note
  phrase_end_note = pick_phrase_endpoint();
  
  // Avoid repeating same endpoint consecutively
  retry_count = 0;
  loop(8,
    (phrase_end_note == last_endpoint_note) ? (
      phrase_end_note = pick_phrase_endpoint();
      retry_count += 1;
    ) : (
      retry_count = 10;  // break
    );
  );
  last_endpoint_note = phrase_end_note;
  
  // Ensure ending note is a chord tone - retry if not
  loop(10,
    !is_chord_tone(phrase_end_note % 12) ? (
      phrase_end_note = pick_phrase_endpoint();
    ) : (
      retry_count = 10;  // break
    );
  );
  
  // Return success if chord tone found
  is_chord_tone(phrase_end_note % 12);
);

// Helper: Determine phrase direction based on available room
function determine_phrase_direction() local(room_above, room_below, semitones_needed, direction, random_direction) (
  room_above = temp_top_note - phrase_end_note;
  room_below = phrase_end_note - temp_base_note;
  
  // Estimate semitones needed (roughly 2 per scale step)
  semitones_needed = phrase_length * 2;
  
  // Pick direction based on available room
  room_below >= semitones_needed ? (
    room_above >= semitones_needed ? (
      // Both directions work - pick randomly
      random_direction = rand();
      direction = random_direction < 0.5 ? 1 : -1;
    ) : (
      // Only room below - must go UP
      direction = 1;
    );
  ) : (
    // Not enough room below - must go DOWN
    direction = -1;
  );
  
  direction;
);

// Helper: Build temporary array of scale notes in extended range
function build_temp_scale_array() local(midi_note, note_class, temp_count) (
  temp_scale_notes = 800;
  temp_count = 0;
  
  // Fill with scale notes in extended range (soft boundaries)
  midi_note = temp_soft_base;
  loop(temp_soft_top - temp_soft_base + 1,
    note_class = midi_note % 12;
    is_scale_tone(note_class) ? (
      temp_scale_notes[temp_count] = midi_note;
      temp_count += 1;
    );
    midi_note += 1;
  );
  
  temp_count;  // Return count
);

// Helper: Validate that we have enough scale notes to build a phrase
function validate_scale_array(temp_count) (
  // Just need enough notes to work with
  temp_count >= 7 ? 1 : 0;
);

// Helper: Find index of a MIDI note in the temp_scale_notes array
function find_scale_index(midi_note, temp_count) local(i, found_idx) (
  found_idx = -1;
  i = 0;
  loop(temp_count,
    temp_scale_notes[i] == midi_note ? found_idx = i;
    i += 1;
  );
  found_idx;
);

// Helper: Find nearest scale note index to a target MIDI note
function find_nearest_scale_index(target_midi, temp_count) local(i, best_idx, best_dist, dist) (
  best_idx = 0;
  best_dist = 999;
  i = 0;
  loop(temp_count,
    dist = abs(temp_scale_notes[i] - target_midi);
    dist < best_dist ? (
      best_dist = dist;
      best_idx = i;
    );
    i += 1;
  );
  best_idx;
);

// Clamp a candidate note so jumps never exceed 7 semitones
function clamp_jump(prev_note, candidate_note, temp_count)
    local(diff, direction, target_note, idx) (
  (prev_note < 0) ? candidate_note : (
    diff = abs(candidate_note - prev_note);
    diff <= 7 ? (
      candidate_note;
    ) : (
      direction = candidate_note >= prev_note ? 1 : -1;
      target_note = prev_note + direction * 7;
      idx = find_nearest_scale_index(target_note, temp_count);
      temp_scale_notes[idx];
    );
  );
);

// Phase 1: Exploration - free movement with direction changes
function build_exploration_phase(start_idx, num_notes, temp_count)
    local(i, note_idx, current_direction, steps_since_dir_change, prev_midi_note,
          midi_note, note_class, distance_from_top, distance_from_bottom,
          near_top_boundary, near_bottom_boundary, min_steps_between,
          dir_change_prob, skip_amount, use_repeat, prev_note_type, curr_note_type,
          consecutive_repeats, consecutive_skips, last_skip_size) (

  note_idx = start_idx;
  current_direction = phrase_direction;
  steps_since_dir_change = 0;
  prev_midi_note = -1;
  prev_note_type = 0;
  consecutive_repeats = 0;
  consecutive_skips = 0;
  last_skip_size = 1;

  i = 0;
  loop(num_notes,
    // Bounds check
    note_idx = max(0, min(temp_count - 1, note_idx));

    midi_note = temp_scale_notes[note_idx];
    note_class = midi_note % 12;

    // Check proximity to boundaries
    distance_from_top = temp_soft_top - midi_note;
    distance_from_bottom = midi_note - temp_soft_base;
    near_top_boundary = distance_from_top <= 3;
    near_bottom_boundary = distance_from_bottom <= 3;

    // Force direction change at boundaries
    near_top_boundary && current_direction > 0 ? (
      current_direction = -1;
      steps_since_dir_change = 0;
    );
    near_bottom_boundary && current_direction < 0 ? (
      current_direction = 1;
      steps_since_dir_change = 0;
    );

    // Random direction changes based on phrase length
    !near_top_boundary && !near_bottom_boundary ? (
      phrase_length <= 8 ? (
        min_steps_between = 4 + floor(rand() * 3);
        dir_change_prob = 0.2;
      ) : phrase_length <= 14 ? (
        min_steps_between = 3 + floor(rand() * 2);
        dir_change_prob = 0.3;
      ) : (
        min_steps_between = 2 + floor(rand() * 2);
        dir_change_prob = 0.4;
      );

      steps_since_dir_change >= min_steps_between ? (
        rand() < dir_change_prob ? (
          current_direction = -current_direction;
          steps_since_dir_change = 0;
        );
      );
    );

    // Determine note type
    curr_note_type = is_chord_tone(note_class) ? 1 : 2;

    // Check for repeat (not on first note, and limit consecutive repeats)
    use_repeat = 0;
    (i > 0 && prev_midi_note > 0 && consecutive_repeats < MAX_CONSECUTIVE_REPEATS) ? (
      prev_note_type == 1 ? (
        rand() < REPEAT_CHORD_PROB ? use_repeat = 1;
      ) : prev_note_type == 2 ? (
        rand() < REPEAT_SCALE_PROB ? use_repeat = 1;
      );
    );

    use_repeat ? (
      phrase_notes[i] = prev_midi_note;
      consecutive_repeats += 1;
      consecutive_skips = 0;  // Reset skip counter on repeat
    ) : (
      // Clamp jump size before committing the note
      midi_note = i > 0 ? clamp_jump(prev_midi_note, midi_note, temp_count) : midi_note;
      
      // Check if we are repeating despite not choosing to (e.g. boundary clamping)
      (i > 0 && midi_note == prev_midi_note) ? (
        consecutive_repeats += 1;
        
        // If we've hit the limit, force a change
        consecutive_repeats > MAX_CONSECUTIVE_REPEATS ? (
           // Find current index and move 1 step away
           note_idx = find_nearest_scale_index(midi_note, temp_count);
           note_idx == 0 ? note_idx += 1 : note_idx -= 1;
           midi_note = temp_scale_notes[note_idx];
           consecutive_repeats = 0;
        );
      ) : (
        consecutive_repeats = 0;
      );

      note_idx = find_nearest_scale_index(midi_note, temp_count);
      note_class = midi_note % 12;

      phrase_notes[i] = midi_note;
      prev_midi_note = midi_note;
      prev_note_type = curr_note_type;

      // Advance with random skip, but limit consecutive large skips
      consecutive_skips >= MAX_CONSECUTIVE_SKIPS ? (
        // Force a step of 1 after too many large skips
        skip_amount = 1;
        consecutive_skips = 0;
      ) : (
        skip_amount = 1 + floor(rand() * rand() * MAX_JUMP);
      );

      // Track consecutive skips >= 2 (thirds and larger sound like arpeggios)
      skip_amount >= 2 ? (
        consecutive_skips += 1;
      ) : (
        consecutive_skips = 0;
      );

      last_skip_size = skip_amount;
      note_idx += current_direction * skip_amount;
    );

    steps_since_dir_change += 1;
    i += 1;
  );

  // Return the final note_idx for resolution phase to use
  note_idx;
);

// Phase 2: Resolution - guided movement toward the endpoint
function build_resolution_phase(start_note_idx, end_note_idx, start_phrase_idx, num_notes, temp_count)
  local(i, note_idx, target_idx, notes_remaining, distance_to_target,
      step_direction, midi_note, note_class, should_step_toward,
      skip_amount, approach_from_below, penultimate_idx,
      last_step_size, consecutive_large_steps, prev_resolution_note,
      prev_resolution_midi) (

  // Decide approach direction for final note
  approach_from_below = rand() < APPROACH_FROM_BELOW_PROB;

  note_idx = start_note_idx;
  target_idx = end_note_idx;
  consecutive_large_steps = 0;
  last_step_size = 1;
  prev_resolution_note = -1;
    prev_resolution_midi = -1;

  i = 0;
  loop(num_notes,
    notes_remaining = num_notes - i;

    // Bounds check
    note_idx = max(0, min(temp_count - 1, note_idx));

    // Last note: force to endpoint
    notes_remaining == 1 ? (
      phrase_notes[start_phrase_idx + i] = phrase_end_note;
    ) : (
      // Second-to-last note: set up the approach
      notes_remaining == 2 ? (
        // Position one step away from target in the chosen approach direction
        approach_from_below ? (
          penultimate_idx = max(0, target_idx - 1);
        ) : (
          penultimate_idx = min(temp_count - 1, target_idx + 1);
        );
        note_idx = penultimate_idx;
        midi_note = temp_scale_notes[note_idx];
        midi_note = prev_resolution_midi >= 0 ? clamp_jump(prev_resolution_midi, midi_note, temp_count) : midi_note;
        note_idx = find_nearest_scale_index(midi_note, temp_count);
        phrase_notes[start_phrase_idx + i] = midi_note;
        prev_resolution_midi = midi_note;
        prev_resolution_note = note_idx;
      ) : (
        // Earlier resolution notes: progressively move toward target
        distance_to_target = target_idx - note_idx;

        // Determine if we should step toward target
        should_step_toward = rand() < RESOLUTION_STEP_BIAS;

        // Calculate direction needed to reach target
        distance_to_target > 0 ? (
          step_direction = 1;
        ) : distance_to_target < 0 ? (
          step_direction = -1;
        ) : (
          step_direction = 0;
        );

        // If we're far from target or should step toward it, move in that direction
        (abs(distance_to_target) > RESOLUTION_START_DISTANCE || should_step_toward) ? (
          // Limit consecutive skips > 1 to prevent arpeggio patterns (thirds sound like arpeggios)
          consecutive_large_steps >= MAX_CONSECUTIVE_SKIPS ? (
            // Force stepwise motion after too many skips
            skip_amount = 1;
            consecutive_large_steps = 0;
          ) : (
            // Heavily favor stepwise motion (85% step of 1, 15% step of 2)
            skip_amount = rand() < 0.85 ? 1 : 2;
          );
          // Don't overshoot the target area
          skip_amount = min(skip_amount, max(1, abs(distance_to_target) - 2));
          note_idx += step_direction * skip_amount;

          // Track consecutive non-stepwise motion (skips >= 2 count as "large")
          skip_amount >= 2 ? (
            consecutive_large_steps += 1;
          ) : (
            consecutive_large_steps = 0;
          );
        ) : (
          // Close to target, allow small wandering or hold position
          consecutive_large_steps = 0;  // Reset on wander
          rand() < 0.4 ? (
            // Sometimes stay on same note for a beat
            note_idx = note_idx;
          ) : rand() < 0.5 ? (
            note_idx += (rand() < 0.5 ? 1 : -1);
          );
        );

        // Bounds check
        note_idx = max(0, min(temp_count - 1, note_idx));

        midi_note = temp_scale_notes[note_idx];
        midi_note = prev_resolution_midi >= 0 ? clamp_jump(prev_resolution_midi, midi_note, temp_count) : midi_note;
        note_idx = find_nearest_scale_index(midi_note, temp_count);
        phrase_notes[start_phrase_idx + i] = midi_note;
        last_step_size = abs(note_idx - (i > 0 ? prev_resolution_note : note_idx));
        prev_resolution_note = note_idx;
        prev_resolution_midi = midi_note;
      );
    );

    i += 1;
  );
);

// Main phrase builder: Two-phase approach (exploration + resolution)
function build_phrase_notes(direction, temp_count)
    local(exploration_notes, resolution_notes, start_idx, end_idx,
          final_exploration_idx, current_note_idx, max_resolution_distance,
          exploration_distance) (

  // Calculate phase lengths
  exploration_notes = floor(phrase_length * EXPLORATION_RATIO);
  exploration_notes = max(1, exploration_notes);  // At least 1 exploration note
  resolution_notes = phrase_length - exploration_notes;
  resolution_notes = max(1, resolution_notes);    // At least 1 resolution note

  // Ensure we don't exceed phrase length
  (exploration_notes + resolution_notes) > phrase_length ? (
    exploration_notes = phrase_length - resolution_notes;
  );

  // Find endpoint index in scale array
  end_idx = find_scale_index(phrase_end_note, temp_count);
  end_idx < 0 ? (
    // Endpoint not exactly on scale, find nearest
    end_idx = find_nearest_scale_index(phrase_end_note, temp_count);
  );

  // Calculate max distance exploration can go based on resolution notes available
  // Resolution can cover ~1.5 scale steps per note with current constraints (mostly stepwise)
  // We want exploration to end within a distance that resolution can comfortably cover
  max_resolution_distance = floor(resolution_notes * 1.3);

  // Calculate starting position - don't start farther than resolution can handle
  // Use the smaller of: phrase_length * 0.8 OR max_resolution_distance
  exploration_distance = min(floor(phrase_length * 0.8), max_resolution_distance);
  start_idx = end_idx - (direction * exploration_distance);
  start_idx = max(0, min(temp_count - 1, start_idx));

  // Phase 1: Exploration
  final_exploration_idx = build_exploration_phase(start_idx, exploration_notes, temp_count);

  // Phase 2: Resolution - start from where exploration ended
  // But first, check if exploration ended too far from target
  // If so, nudge it closer to ensure smooth resolution
  current_note_idx = max(0, min(temp_count - 1, final_exploration_idx));

  // Safety check: if we're too far from target for the remaining notes, move closer
  abs(current_note_idx - end_idx) > (resolution_notes * 2) ? (
    // We're too far - move starting point closer to target
    // Leave enough room for resolution to have musical movement
    direction > 0 ? (
      current_note_idx = max(0, end_idx - resolution_notes - 1);
    ) : (
      current_note_idx = min(temp_count - 1, end_idx + resolution_notes + 1);
    );
  );

  build_resolution_phase(current_note_idx, end_idx, exploration_notes, resolution_notes, temp_count);

  1;  // Return success
);

// Build entire phrase by walking scale from calculated start to pre-selected end
function build_phrase_from_endpoint() local(max_phrase, min_phrase, direction, temp_count, success, target_next_chord, saved_slider3, next_chord_idx, valid_endpoint) (
  phrase_build_counter += 1;

  // Step 1: Initialize boundaries
  init_phrase_boundaries();

  // Step 2: Determine phrase length FIRST (so we know if we cross chord boundary)
  max_phrase = min(slider7, slider5 * 7);
  min_phrase = min(slider6, max_phrase);
  random_length = rand();
  phrase_length = min_phrase + floor(random_length * (max_phrase - min_phrase + 1));

  // Step 3: Check if we cross chord boundary and should target next chord
  target_next_chord = 0;
  (slider15 == 1) ? (
    rand() < CHORD_BOUNDARY_RESPECT_PROB ? (
      // Truncate to fit in current chord (moved from build_phrase_notes)
      phrase_length = min(phrase_length, max(2, prog_beats_until_change - 1));
    ) : (
      // Allowed to cross. If phrase is long enough, target next chord
      (phrase_length * 0.5 > prog_beats_until_change) ? target_next_chord = 1;
    );
  );

  // Step 4: Pick and validate endpoint
  // If targeting next chord, temporarily switch context
  target_next_chord ? (
    saved_slider3 = slider3;
    next_chord_idx = (prog_chord_index + 1) % slider16;
    slider3 = prog_chords[next_chord_idx];
    build_chord_tones();
  );

  valid_endpoint = pick_and_validate_endpoint();

  target_next_chord ? (
    slider3 = saved_slider3;
    build_chord_tones();
  );

  valid_endpoint ? (
    // Endpoint is valid chord tone, continue

    // Step 5: Determine direction (which way to start exploring)
    direction = determine_phrase_direction();
    phrase_direction = direction;

    // Step 6: Build temp scale array
    temp_count = build_temp_scale_array();

    // Step 7: Validate we have enough notes
    validate_scale_array(temp_count) ? (

      // Step 8: Build phrase using two-phase approach
      // Phase 1 (exploration) + Phase 2 (resolution to endpoint)
      success = build_phrase_notes(direction, temp_count);

      // Step 9: Schedule events and finalize
      success ? (
        schedule_phrase_events();
        bias_phrase_end_to_downbeat();
        phrase_active = 1;
        phrase_slot_index = 0;
        phrase_start_beat = -1;  // Will be set on first playback tick
        phrase_built_for_chord = slider3;  // Store which chord this phrase was built for
      ) : (
        // Build failed
        phrase_active = 0;
        between_phrase_rest = 1;
      );
    ) : (
      // Not enough scale notes
      phrase_active = 0;
      between_phrase_rest = 1;
    );
  ) : (
    // Failed to find chord tone endpoint
    phrase_active = 0;
    between_phrase_rest = 1;
  );
);

// ============================================
// MIDI OUTPUT FUNCTIONS
// ============================================

function send_note_on(note, vel) (
  midisend(0, $x90 + (slider14 > 0 ? slider14 - 1 : 0), note, vel);
  note_playing = note;
);

function send_note_off() (
  note_playing > 0 ? (
    midisend(0, $x80 + (slider14 > 0 ? slider14 - 1 : 0), note_playing, 0);
    note_playing = 0;
  );
);

@slider
build_scale();
build_chord_tones();

@block
// ============================================
// PROGRESSION SEQUENCER
// ============================================
(slider15 == 1) ? (  // Auto-Loop mode enabled
  // Calculate current beat number from beat_position
  beat_num = floor(beat_position);
  
  // Initialize progression array on first run
  prog_last_beat_num < 0 ? (
    prog_beat_counter = 0;
    prog_chord_index = 0;
    prog_last_beat_num = beat_num;
    prog_current_chord = -1;  // Force rebuild on first beat
    
    // Rebuild progression array from sliders
    prog_chords[0] = slider17;
    prog_chords[1] = slider18;
    prog_chords[2] = slider19;
    prog_chords[3] = slider20;
  );
  
  // Detect beat changes (beat_num increments on each quarter note)
  beat_num != prog_last_beat_num ? (
    prog_last_beat_num = beat_num;
    prog_beat_counter += 1;
    
    // Time to advance to next chord? (slider21 is in measures, multiply by 4 for beats)
    prog_beat_counter >= (slider21 * 4) ? (
      prog_beat_counter = 0;
      prog_chord_index = (prog_chord_index + 1) % slider16;
      // Reset rest so new chord starts immediately if we were waiting
      between_phrase_rest = 0;
    );
    
    // Update current chord from progression
    new_chord = prog_chords[prog_chord_index];
    
    // If chord changed, rebuild chord tones
    new_chord != prog_current_chord ? (
      prog_current_chord = new_chord;
      // Manually set slider3 and rebuild
      slider3 = prog_current_chord;
      sliderchange(slider3);
      build_chord_tones();
    );
  );
  
  // Calculate beats remaining until chord change
  prog_beats_until_change = (slider21 * 4) - prog_beat_counter;
) : (
  // Reset progression state when mode is Off
  prog_last_beat_num < 0 ? (
    prog_last_beat_num = 0;
  );
  prog_beats_until_change = 999;
);

// Pass through incoming MIDI (always, regardless of generation state)
while(midirecv(offset, msg1, msg2, msg3)) (
  midisend(offset, msg1, msg2, msg3);
);

(slider12 == 1 && play_position > 0) ? ( // Generation enabled (skip if stopped)
  // Calculate current 8th-note slot from beat position
  current_eighth = floor(beat_position * 2);

  // Detect loop or seek (beat position jumped backwards or significantly forwards)
  (last_beat_position >= 0 && (beat_position < last_beat_position || beat_position > last_beat_position + 4)) ? (
    // Reset phrase state on seek/loop
    send_note_off();
    phrase_active = 0;
    between_phrase_rest = 0;
  );
  last_beat_position = beat_position;

  // Build first phrase if needed
  (!phrase_active && between_phrase_rest == 0 && phrase_slot_count == 0) ? (
    build_phrase_from_endpoint();
  );

  // New 8th note boundary?
  current_eighth != last_eighth ? (
    last_eighth = current_eighth;

    !phrase_active ? (
      // Not in phrase - handle rest countdown (on every 8th boundary)
      between_phrase_rest > 0 ? (
        between_phrase_rest -= 1;
        between_phrase_rest == 0 ? (
          build_phrase_from_endpoint();
        );
      ) : (
        // No rest pending, build new phrase
        build_phrase_from_endpoint();
      );
    );

    phrase_active ? (
      // Set start beat on first tick of phrase
      phrase_start_beat < 0 ? (
        phrase_start_beat = current_eighth / 2;
        phrase_start_eighth = current_eighth;
        phrase_slot_index = 0;
      );

      // Calculate which slot we should be at (using integer math)
      phrase_slot_index = current_eighth - phrase_start_eighth;

      // Still within phrase?
      phrase_slot_index < phrase_slot_count ? (
        // Get note and velocity for this slot
        note = phrase_events[phrase_slot_index];
        velocity = phrase_velocities[phrase_slot_index];

        // Play if there's a note (0 = rest)
        note > 0 ? (
          send_note_off();
          send_note_on(note, velocity);
        ) : (
          // Rest (0) - stop previous note if playing
          send_note_off();
        );
      ) : (
        // Phrase complete - start rest period
        send_note_off();
        phrase_active = 0;
        between_phrase_rest = phrase_rest_after;
      );
    );
  );
);

@gfx 450 300
// ============================================
// GRAPHICS / UI
// ============================================

// Layout Constants
margin = 20;
header_h = 30;
chord_section_h = 70;
viz_h = 120;

// Clear background (Dark Grey)
gfx_set(0.1, 0.1, 0.1, 1);
gfx_rect(0, 0, gfx_w, gfx_h);

// Fonts
gfx_setfont(1, "Arial", 14);      // Label
gfx_setfont(2, "Arial", 32, 'b'); // Big Chord
gfx_setfont(3, "Arial", 18);      // Normal
gfx_setfont(4, "Arial", 12);      // Small

// 1. Header (Key & Scale)
gfx_x = margin; gfx_y = margin;
gfx_set(0.6, 0.6, 0.6, 1); // Dim text
gfx_setfont(1);
gfx_drawstr("KEY: ");
gfx_set(1, 1, 1, 1); // White
gfx_print_note_class(slider1);
gfx_drawstr(" ");
slider2 == 0 ? gfx_drawstr("Major") : slider2 == 1 ? gfx_drawstr("Minor") : gfx_drawstr("Dorian");

// 2. Chord Display
gfx_y += 30;
current_y = gfx_y;

// Current Chord
gfx_x = margin;
gfx_set(0.4, 0.8, 1.0, 1); // Blue label
gfx_setfont(1);
gfx_drawstr("CURRENT CHORD");
gfx_y += 20;
gfx_x = margin;
gfx_set(1, 1, 1, 1);
gfx_setfont(2);
display_current_chord = (slider15 == 1) ? prog_current_chord : slider3;
gfx_print_chord_name(display_current_chord);

// Next Chord (if auto)
(slider15 == 1) ? (
  gfx_x = gfx_w / 2;
  gfx_y = current_y;
  gfx_set(0.4, 0.8, 1.0, 1);
  gfx_setfont(1);
  gfx_drawstr("NEXT CHORD");
  gfx_y += 20;
  gfx_x = gfx_w / 2;
  gfx_set(0.7, 0.7, 0.7, 1); // Dimmer white
  gfx_setfont(2);
  display_next_chord = prog_chords[(prog_chord_index + 1) % slider16];
  gfx_print_chord_name(display_next_chord);
);

// 3. Phrase Visualization
gfx_y = current_y + chord_section_h;
viz_y = gfx_y;
viz_w = gfx_w - 2*margin;

// Background for viz
gfx_set(0.15, 0.15, 0.15, 1);
gfx_rect(margin, viz_y, viz_w, viz_h);

// Draw Phrase or Rest status
(phrase_active && phrase_slot_count > 0) ? (
  // Find range for auto-scaling
  min_note = 127; max_note = 0;
  i = 0;
  loop(phrase_slot_count,
    n = phrase_events[i];
    n > 0 ? (
      min_note = min(min_note, n);
      max_note = max(max_note, n);
    );
    i += 1;
  );
  
  // Padding for range
  range = max(12, max_note - min_note); // Min range of octave
  mid = (min_note + max_note) / 2;
  min_note = mid - range/2;
  
  slot_w = viz_w / phrase_slot_count;
  
  i = 0;
  loop(phrase_slot_count,
    n = phrase_events[i];
    x = margin + i * slot_w;
    
    // Draw grid line (every beat = 2 slots)
    (i % 2 == 0) ? (
      gfx_set(0.2, 0.2, 0.2, 1);
      gfx_line(x, viz_y, x, viz_y + viz_h);
    );
    
    n > 0 ? (
      // Draw Note
      norm_p = (n - min_note) / range;
      norm_p = max(0, min(1, norm_p));
      
      h = 10; // fixed height bars
      y = viz_y + viz_h - (norm_p * (viz_h - 30)) - 20;
      
      // Color based on active
      (i == phrase_slot_index) ? gfx_set(1, 1, 1, 1) : gfx_set(0.4, 0.8, 0.5, 0.8);
      
      gfx_rect(x + 1, y, slot_w - 2, h);
      
      // Draw note name if wide enough
      slot_w > 25 ? (
        gfx_x = x + 2; gfx_y = y - 12;
        gfx_setfont(4);
        gfx_set(1,1,1,0.5);
        gfx_print_note_name(n);
      );
    );
    i += 1;
  );
  
  // Playhead
  px = margin + phrase_slot_index * slot_w;
  gfx_set(1, 0.3, 0.3, 0.8);
  gfx_rect(px, viz_y, 2, viz_h);
  
) : (
  // Resting State
  gfx_x = margin + 20;
  gfx_y = viz_y + viz_h/2 - 10;
  gfx_setfont(3);
  gfx_set(0.6, 0.6, 0.6, 1);
  
  between_phrase_rest > 0 ? (
    gfx_drawstr("Resting... ");
    gfx_printf("%d", between_phrase_rest);
    gfx_drawstr(" beats");
  ) : (
    !slider12 ? gfx_drawstr("Generation Disabled") : gfx_drawstr("Waiting...");
  );
);

// 4. Footer / Status
gfx_y = viz_y + viz_h + 10;
gfx_x = margin;
gfx_setfont(4);
gfx_set(0.5, 0.5, 0.5, 1);
gfx_drawstr("Density: "); 
gfx_printf("%d%%", slider9 * 100);
gfx_drawstr("  |  Range: ");
gfx_printf("%d", slider5);
gfx_drawstr(" oct");
