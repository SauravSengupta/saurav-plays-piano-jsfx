version: 1.0.5
desc: Phrase Maker
author: Saurav Plays Piano
about:
  # Phrase Maker
  A basic generative phrase engine that tries to create melodic phrases based on musical theory.

// Phrase Maker
// Copyright (c) 2026 Saurav Plays Piano
// Licensed under the MIT License

// === MUSICAL SETTINGS ===
slider1:0<0,11,1{C,C#,D,D#,E,F,F#,G,G#,A,A#,B}>Root Note
slider2:0<0,2,1{Major (bright happy),Minor (dark sad),Lydian (dreamy bright)}>Scale

// === RANGE SETTINGS ===
slider3:3<0,5,1{C1,C2,C3,C4,C5,C6}>Base Octave
slider4:2<1,4,1>Octave Range

// === PHRASE SETTINGS ===
slider5:6<4,12,1>Min Phrase Length
slider6:16<12,24,1>Max Phrase Length
slider7:0.4<0,1,0.05>Density (sparse to busy)

// === PROGRESSION SEQUENCER ===
slider8:4<1,8,1>Loop Length (# of chords)
slider9:0<0,6,1{I,ii,iii,IV,V,vi,II}>Prog Chord 1
slider10:4<0,6,1{I,ii,iii,IV,V,vi,II}>Prog Chord 2
slider11:5<0,6,1{I,ii,iii,IV,V,vi,II}>Prog Chord 3
slider12:3<0,6,1{I,ii,iii,IV,V,vi,II}>Prog Chord 4
slider13:4<1,8,1>Measures Per Chord
slider14:0<0,1,{Off,On}>-Continuous Mode
slider15:1<0,4,1{Half (0.5x),Normal (1x),Double (2x),Quad (4x),Oct (8x)}>Playback Speed

// === PERFORMANCE ===
slider16:60<1,127,1>Min Velocity
slider17:100<1,127,1>Max Velocity
slider18:0.5<0,1,0.05>Humanize Timing
slider19:0.1<0,1,0.05>Chord Voicing
slider20:1<0,1,{Off,On}>Sustain Pedal Modeling

// === SYSTEM ===
slider21:1<0,1,{Off,On}>Enable Generation
slider22:0<0,16,1{Omni,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}>MIDI Channel

in_pin:none
out_pin:none

@init
// ============================================
// CONSTANTS
// ============================================

// Weight constants for note selection
CHORD_ROOT_WEIGHT = 80;   // Root - Grounding (lowered slightly to reduce finality)
CHORD_FIFTH_WEIGHT = 35;  // 5th - Open/Spacious (Boosted for ambient feel)
CHORD_SEVENTH_WEIGHT = 10;// 7th - Floating/Unresolved (New)
CHORD_THIRD_WEIGHT = 10;  // 3rd - Emotional definition (Lowered for background)
SCALE_TONE_WEIGHT = 4;    // Non-chord scale degrees
PASSING_TONE_WEIGHT = 1;  // Chromatic passing tones

// Probability constants
REPEAT_CHORD_PROB = 0.15;          // Chance to repeat previous chord tone
REPEAT_SCALE_PROB = 0.08;          // Chance to repeat previous scale tone
INNER_REST_BASE = 0.6;             // Base inner rest probability scale at low density

// Phrase movement constants (controls note-to-note stepping behavior)
MAX_JUMP = 4;  // Maximum scale notes to jump; longer jumps have lower probability

// Phase balance constants (controls exploration vs resolution)
EXPLORATION_RATIO = 0.65;          // Fraction of phrase spent exploring (0.5-0.8)
RESOLUTION_START_DISTANCE = 6;     // Start resolving when within N scale steps of target
RESOLUTION_STEP_BIAS = 0.5;        // Probability of stepping toward target in resolution (0.5-1.0) - lowered to allow more wandering
APPROACH_FROM_BELOW_PROB = 0.6;    // Probability of approaching final note from below
MAX_CONSECUTIVE_REPEATS = 2;       // Maximum times a note can repeat consecutively
MAX_CONSECUTIVE_SKIPS = 1;         // Maximum consecutive large intervals (>=2 scale steps) - set to 1 to prevent arpeggio patterns
CHORD_BOUNDARY_RESPECT_PROB = 0.8; // Probability of ending phrase near chord boundary (0.8 = 80% respect, 20% overshoot)
DOWNBEAT_END_BIAS = 0.65;          // Probability to snap phrase end to nearest measure downbeat when close
DOWNBEAT_SNAP_WINDOW = 1.0;        // Max distance (in beats) from a downbeat to allow snapping
DOWNBEAT_REST_BONUS = 2;           // Extra quarter notes of rest when phrase ends on downbeat
SOFT_BOUNDARY_EXTENSION = 2;       // Semitones to extend beyond octave range for smooth voice leading

// Rest behavior constants (controls between-phrase rest lengths)
// These are in quarter notes (decremented once per beat_num change)
REST_MAX_BASE = 2;      // Base max rest at low density
REST_MIN_BASE = 1;      // Base min rest at low density
REST_MIN_FLOOR = 1;     // Absolute minimum rest
REST_MAX_CEILING = 4;   // Maximum allowed rest

// Chord tone sustain constants
SUSTAIN_ROOT_PROB = 0.80;      // Probability root gets extended
SUSTAIN_FIFTH_PROB = 0.70;     // Probability fifth gets extended
SUSTAIN_THIRD_PROB = 0.50;     // Probability third gets extended
SUSTAIN_SEVENTH_PROB = 0.40;   // Probability seventh gets extended
SUSTAIN_MIN_EXTENSION = 2;     // Minimum extension in slots (1 slot = 1 eighth note)
SUSTAIN_MAX_CONCURRENT = 3;    // Maximum simultaneously held chord tones
SUSTAIN_EARLY_BONUS = 0.1;     // Extra extension probability early in phrase
SUSTAIN_LATE_PENALTY = 0.2;    // Reduced extension probability late in phrase
SUSTAIN_LATE_MAX_SLOTS = 4;    // Max extension slots in late phrase

// Pedal behavior constants
PEDAL_DISSONANCE_THRESHOLD = 1.2;  // Accumulated mud before pedal lifts
PEDAL_CHORD_TONE_CLEAR = 0.3;      // How much chord tones reduce mud
PEDAL_SCALE_TONE_MUD = 0.5;        // How much scale tones add mud
PEDAL_PASSING_TONE_MUD = 0.8;      // How much passing tones add mud

// Humanization constants (timing feel)
HUMANIZE_MAX_MS = 25;              // Maximum timing offset in milliseconds
HUMANIZE_VEL_CORRELATION = 0.7;    // How much velocity affects timing (0-1)
HUMANIZE_DURATION_VAR = 0.3;       // Duration variation factor (0-1)
HUMANIZE_STACCATO_PROB = 0.15;     // Probability of staccato articulation

// Chord voicing constants (harmony notes)
HARMONY_TIMING_OFFSET_MS = 5;      // Slight delay for harmony note (ms)
HARMONY_VEL_REDUCTION = 0.85;      // Velocity multiplier for harmony (softer)

// ============================================
// MEMORY LAYOUT - SCALE DEFINITIONS
// ============================================

// Scale intervals (semitones from root)
// Major: W W H W W W H
scale_major = 0; // Array index
scale_major[0] = 0; scale_major[1] = 2; scale_major[2] = 4; scale_major[3] = 5;
scale_major[4] = 7; scale_major[5] = 9; scale_major[6] = 11;

// Minor: W H W W H W W
scale_minor = 10;
scale_minor[0] = 0; scale_minor[1] = 2; scale_minor[2] = 3; scale_minor[3] = 5;
scale_minor[4] = 7; scale_minor[5] = 8; scale_minor[6] = 10;

// Lydian: W W W H W W H
scale_lydian = 20;
scale_lydian[0] = 0; scale_lydian[1] = 2; scale_lydian[2] = 4; scale_lydian[3] = 6;
scale_lydian[4] = 7; scale_lydian[5] = 9; scale_lydian[6] = 11;

// Chord degree offsets (scale degrees, 0-indexed)
// I (0), ii (1), iii (2), IV (3), V (4), vi (5), II (6)
chord_degrees = 100;
chord_degrees[0] = 0;  // I
chord_degrees[1] = 1;  // ii
chord_degrees[2] = 2;  // iii
chord_degrees[3] = 3;  // IV
chord_degrees[4] = 4;  // V
chord_degrees[5] = 5;  // vi
chord_degrees[6] = 1;  // II (2nd degree)

// Chord quality (0=major, 1=minor, 2=dim)
chord_quality = 120;
chord_quality[0] = 0; // I - major
chord_quality[1] = 1; // ii - minor
chord_quality[2] = 1; // iii - minor
chord_quality[3] = 0; // IV - major
chord_quality[4] = 0; // V - major
chord_quality[5] = 1; // vi - minor
chord_quality[6] = 0; // II - major

// Working arrays
current_scale = 200;      // 7 notes
current_chord_tones = 210; // up to 4 notes (root, 3rd, 5th, 7th)
current_chord_idx = 0;    // Internal variable for current chord (0-5)
available_notes = 220;    // all available MIDI notes with weights
note_weights = 300;       // parallel array of weights
note_history = 400;       // History of recent notes for variation
note_history_size = 8;    // Number of notes to remember
note_history_idx = 0;     // Current ring buffer index

// Playback state
note_playing = 0;
last_eighth = -1;  // Last 8th-note boundary processed
last_phrase_end_velocity = -1;

// Phrase generation state
phrase_active = 0;              // Are we currently in a phrase?
phrase_length = 0;              // Notes to generate in current phrase (for build phase)
between_phrase_rest = 0;        // Quarter notes of rest before next phrase
phrase_end_note = -1;           // Ending note of phrase (planned)
phrase_direction = 0;           // -1 = down, 0 = neutral, 1 = up (for melodic momentum)

// Pre-calculated phrase data (step sequencer model)
// Each index = one 8th note slot. 0 = rest/silence at that slot.
phrase_events = 700;      // MIDI note at each 8th-note slot (0 = rest)
phrase_velocities = 780;  // Velocity for each slot
phrase_slot_count = 0;    // Total 8th-note slots in this phrase
phrase_slot_index = 0;    // Current playback position
phrase_rest_after = 0;    // Quarter notes of rest after this phrase
phrase_start_beat = 0;    // Beat position when phrase started
phrase_start_eighth = 0;  // 8th note counter when phrase started
phrase_built_for_chord = -1; // Which chord (slider3 value) this phrase was created for

// Legacy array for note generation (before scheduling)
phrase_notes = 860;       // Temporary: raw MIDI notes before timing applied

// Track last endpoint to avoid repeats
last_endpoint_note = -1;

// Background generation state
// Progression sequencer state
prog_chord_index = 0;         // Current chord in the progression (0-7)
prog_beat_counter = 0;        // Beats elapsed in current chord
prog_last_beat_num = -1;      // Track beat changes (-1 = uninitialized)
prog_chords = 900;            // Array to store the progression sequence
prog_current_chord = -1;      // Currently active chord (-1 = uninitialized)
prog_beats_until_change = 0;  // Beats remaining until next chord change
last_beat_position = -1;      // Track playback position for seek/loop detection
last_speed_mult = -1;         // Track speed changes

// Scheduling context (passed from builder to scheduler)
sched_target_next_chord = 0;
sched_next_chord_idx = 0;
sched_boundary_beats = 0;

// Visualization History
viz_buffer_size = 128;
viz_buffer_pitch = 1000;
viz_buffer_start = 1200;
viz_buffer_len = 1400;
viz_head = 0;

// Chord tone sustain arrays
phrase_note_offs = 1600;      // Slot index when each note should stop (-1 = next note)
held_notes = 1680;            // MIDI notes currently being held (up to SUSTAIN_MAX_CONCURRENT)
held_note_end_slots = 1690;   // Absolute eighth-note when each held note should release
held_count = 0;               // Number of currently held notes

// Pedal state and scheduling
phrase_pedal = 1700;          // Pedal state at each slot (1 = down, 0 = up)
pedal_down = 0;               // Current pedal state during playback
harmonic_mud = 0;             // Accumulated dissonance for pedal decisions
last_pedal_modeling = -1;     // Track pedal modeling slider changes

// Humanization arrays (timing feel)
phrase_timing_offset = 1800;  // Sample offset for each slot (delay in samples)
phrase_duration_mod = 1880;   // Duration modification factor per slot (0-1 scale)

// Pending notes queue (for humanization delays beyond block size)
pending_note_pitch = 1960;    // MIDI note numbers waiting to be sent
pending_note_vel = 2040;      // Velocities for pending notes
pending_note_sample = 2120;   // Absolute sample position when each should play
pending_note_is_harmony = 2200; // 1 if harmony note, 0 if main note
pending_note_count = 0;       // Number of notes in queue
current_sample_pos = 0;       // Absolute sample position tracker

// Chord voicing arrays (harmony notes)
phrase_harmony_note = 2280;   // Harmony note for each slot (0 = none)
harmony_note_playing = 0;     // Currently playing harmony note

// ============================================
// SCALE & CHORD FUNCTIONS
// ============================================

function get_scale_base() (
  slider2 == 0 ? scale_major :
  slider2 == 1 ? scale_minor :
  scale_lydian;
);

function build_scale() local(i, base, root) (
  root = slider1; // 0-11
  base = get_scale_base();
  i = 0;
  loop(7,
    current_scale[i] = (root + base[i]) % 12;
    i += 1;
  );
);

function build_chord_tones() local(degree, quality, root_idx, third_idx, fifth_idx, base) (
  degree = chord_degrees[current_chord_idx];
  quality = chord_quality[current_chord_idx];
  base = get_scale_base();

  // Root of chord (scale degree)
  current_chord_tones[0] = current_scale[degree];

  // Special handling for II (Major II) - Index 6
  current_chord_idx == 6 ? (
    // Force Major 3rd and Perfect 5th (chromatic alteration if needed)
    current_chord_tones[1] = (current_chord_tones[0] + 4) % 12;
    current_chord_tones[2] = (current_chord_tones[0] + 7) % 12;
    // Keep scale 7th
    current_chord_tones[3] = current_scale[(degree + 6) % 7];
  ) : (
    // Standard diatonic logic
    // Third (2 scale steps up)
    third_idx = (degree + 2) % 7;
    current_chord_tones[1] = current_scale[third_idx];

    // Fifth (4 scale steps up)
    fifth_idx = (degree + 4) % 7;
    current_chord_tones[2] = current_scale[fifth_idx];

    // Optional 7th (6 scale steps up)
    current_chord_tones[3] = current_scale[(degree + 6) % 7];
  );
);

// Render a note name (C, C#, etc) without octave
function gfx_print_note_class(note_val) (
  note_val = note_val % 12;
  note_val == 0 ? gfx_printf("C") :
  note_val == 1 ? gfx_printf("C#") :
  note_val == 2 ? gfx_printf("D") :
  note_val == 3 ? gfx_printf("D#") :
  note_val == 4 ? gfx_printf("E") :
  note_val == 5 ? gfx_printf("F") :
  note_val == 6 ? gfx_printf("F#") :
  note_val == 7 ? gfx_printf("G") :
  note_val == 8 ? gfx_printf("G#") :
  note_val == 9 ? gfx_printf("A") :
  note_val == 10 ? gfx_printf("A#") :
  gfx_printf("B");
);

// Render a chord name (e.g. C, Am, G#dim)
function gfx_print_chord_name(chord_idx) local(degree, root_note, third_note, fifth_note, interval_third, interval_fifth) (
  chord_idx < 0 ? (
    gfx_printf("--");
  ) : (
    degree = chord_degrees[chord_idx];
    
    // Get notes from current scale
    root_note = current_scale[degree];
    
    chord_idx == 6 ? (
      // II is forced Major
      third_note = (root_note + 4) % 12;
      fifth_note = (root_note + 7) % 12;
    ) : (
      third_note = current_scale[(degree + 2) % 7];
      fifth_note = current_scale[(degree + 4) % 7];
    );
    
    // Calculate intervals
    interval_third = (third_note - root_note + 12) % 12;
    interval_fifth = (fifth_note - root_note + 12) % 12;
    
    // Print Root
    gfx_print_note_class(root_note);
    
    // Print Quality
    interval_third == 3 ? (
      interval_fifth == 6 ? gfx_printf("dim") : gfx_printf("m");
    ) : (
      interval_fifth == 8 ? gfx_printf("aug");
    );
  );
);

// Render a MIDI note name with octave (C-1 = 0). Uses short names for HUD.
function gfx_print_note_name(midi_note) local(note_class, octave) (
  midi_note <= 0 ? (
    gfx_printf("--");
  ) : (
    note_class = midi_note % 12;
    octave = floor(midi_note / 12) - 1;  // MIDI 60 -> octave 4
    note_class == 0  ? gfx_printf("C%d", octave) :
    note_class == 1  ? gfx_printf("C#%d", octave) :
    note_class == 2  ? gfx_printf("D%d", octave) :
    note_class == 3  ? gfx_printf("D#%d", octave) :
    note_class == 4  ? gfx_printf("E%d", octave) :
    note_class == 5  ? gfx_printf("F%d", octave) :
    note_class == 6  ? gfx_printf("F#%d", octave) :
    note_class == 7  ? gfx_printf("G%d", octave) :
    note_class == 8  ? gfx_printf("G#%d", octave) :
    note_class == 9  ? gfx_printf("A%d", octave) :
    note_class == 10 ? gfx_printf("A#%d", octave) : gfx_printf("B%d", octave);
  );
);

function is_chord_tone(note_class) local(i, found) (
  found = 0;
  i = 0;
  loop(4, // Check root, 3rd, 5th, 7th
    note_class == current_chord_tones[i] ? found = 1;
    i += 1;
  );
  found;
);

// Get the weight for a note based on its chord role
function get_chord_tone_weight(note_class) local(i, weight) (
  weight = 0;
  i = 0;
  loop(4,
    note_class == current_chord_tones[i] ? (
      i == 0 ? weight = CHORD_ROOT_WEIGHT :   // Root
      i == 1 ? weight = CHORD_THIRD_WEIGHT :  // 3rd
      i == 2 ? weight = CHORD_FIFTH_WEIGHT :  // 5th
      weight = CHORD_SEVENTH_WEIGHT;          // 7th
    );
    i += 1;
  );
  weight;
);

function is_scale_tone(note_class) local(i, found) (
  found = 0;
  i = 0;
  loop(7,
    note_class == current_scale[i] ? found = 1;
    i += 1;
  );
  found;
);

// Check how recently a note was played (returns 0-1, where 1 = most recent)
function get_recency_penalty(midi_note) local(i, pos, recency) (
  recency = 0;
  i = 0;
  loop(note_history_size,
    // Check from most recent backwards
    pos = (note_history_idx - 1 - i + note_history_size) % note_history_size;
    note_history[pos] == midi_note ? (
      // More recent = higher penalty. Position 0 (most recent) = 1.0, position 7 = 0.125
      recency = max(recency, 1 / (i + 1));
    );
    i += 1;
  );
  recency;
);

// Unified note selection weight: chord tones > scale tones > passing tones
function get_note_selection_weight(midi_note) local(note_class, weight, penalty) (
  note_class = midi_note % 12;
  weight = 0;
  is_chord_tone(note_class) ? (
    weight = get_chord_tone_weight(note_class);
  ) : is_scale_tone(note_class) ? (
    weight = SCALE_TONE_WEIGHT;
  ) : (
    weight = PASSING_TONE_WEIGHT;
  );
  
  // Apply recency penalty to encourage variety
  penalty = get_recency_penalty(midi_note);
  weight = weight * (1.0 - (penalty * 0.8)); // Reduce weight by up to 80% if recently played
  weight;
);

// Add note to history
function add_to_history(midi_note) (
  note_history[note_history_idx] = midi_note;
  note_history_idx = (note_history_idx + 1) % note_history_size;
);

// ============================================
// CHORD TONE SUSTAIN FUNCTIONS
// ============================================

// Get which chord tone index this note is (0=root, 1=third, 2=fifth, 3=seventh)
// Returns -1 if not a chord tone
function get_chord_tone_index(note_class) local(i, found_idx) (
  found_idx = -1;
  i = 0;
  loop(4,
    note_class == current_chord_tones[i] ? found_idx = i;
    i += 1;
  );
  found_idx;
);

// Get sustain probability for a chord tone index
function get_sustain_probability(tone_idx) (
  tone_idx == 0 ? SUSTAIN_ROOT_PROB :
  tone_idx == 2 ? SUSTAIN_FIFTH_PROB :
  tone_idx == 3 ? SUSTAIN_SEVENTH_PROB :
  SUSTAIN_THIRD_PROB;
);

// Add a note to the held notes array
function add_to_held_notes(midi_note, end_eighth) local(i, oldest_idx, oldest_end) (
  // Check if we're at max capacity
  held_count >= SUSTAIN_MAX_CONCURRENT ? (
    // Find and release the oldest held note (earliest end time)
    oldest_idx = 0;
    oldest_end = held_note_end_slots[0];
    i = 1;
    loop(held_count - 1,
      held_note_end_slots[i] < oldest_end ? (
        oldest_end = held_note_end_slots[i];
        oldest_idx = i;
      );
      i += 1;
    );
    // Send note-off for oldest
    midisend(0, $x80 + (slider22 > 0 ? slider22 - 1 : 0), held_notes[oldest_idx], 0);
    // Shift remaining notes down
    i = oldest_idx;
    loop(held_count - oldest_idx - 1,
      held_notes[i] = held_notes[i + 1];
      held_note_end_slots[i] = held_note_end_slots[i + 1];
      i += 1;
    );
    held_count -= 1;
  );

  // Add new note
  held_notes[held_count] = midi_note;
  held_note_end_slots[held_count] = end_eighth;
  held_count += 1;
);

// Check if a note is currently being held
function is_being_held(midi_note) local(i, found) (
  found = 0;
  i = 0;
  loop(held_count,
    held_notes[i] == midi_note ? found = 1;
    i += 1;
  );
  found;
);

// Release all held notes that should end at or before current_eighth
function check_and_release_held_notes(current_eighth) local(i, j, released) (
  released = 1;
  // Keep releasing until no more to release (handles multiple releases per slot)
  while(released) (
    released = 0;
    i = 0;
    loop(held_count,
      (!released && held_note_end_slots[i] <= current_eighth) ? (
        // Send note-off
        midisend(0, $x80 + (slider22 > 0 ? slider22 - 1 : 0), held_notes[i], 0);
        // Shift remaining notes down
        j = i;
        loop(held_count - i - 1,
          held_notes[j] = held_notes[j + 1];
          held_note_end_slots[j] = held_note_end_slots[j + 1];
          j += 1;
        );
        held_count -= 1;
        released = 1;
      );
      i += 1;
    );
  );
);

// Release all held notes (for phrase end / seek / chord change)
function release_all_held_notes() local(i) (
  i = 0;
  loop(held_count,
    midisend(0, $x80 + (slider22 > 0 ? slider22 - 1 : 0), held_notes[i], 0);
    i += 1;
  );
  held_count = 0;
);

// ============================================
// PEDAL FUNCTIONS
// ============================================

function send_pedal_on() (
  !pedal_down ? (
    midisend(0, $xB0 + (slider22 > 0 ? slider22 - 1 : 0), 64, 127);
    pedal_down = 1;
  );
);

function send_pedal_off() (
  pedal_down ? (
    midisend(0, $xB0 + (slider22 > 0 ? slider22 - 1 : 0), 64, 0);
    pedal_down = 0;
  );
);

// ============================================
// PHRASE SCHEDULING (convert notes to timed events)
// ============================================

// Schedule phrase_notes into phrase_events timeline
// Applies timing (8th notes), inner rests, calculates velocities, and schedules sustain/pedal
function schedule_phrase_events() local(i, slot, note, prev_note, note_diff,
    density, inner_rest_prob, rest_scale, base_inner_rest,
    rest_weight, rest_multiplier, rest_emphasis, velocity, vel_range,
    sparse_boost, min_rest, max_rest, original_chord_idx, switched_context,
    current_beat_time, note_class, chord_tone_idx, sustain_prob, position_factor,
    density_factor, max_extension, extension_slots, sched_mud,
    humanize, base_offset_ms, vel_normalized, vel_timing_shift, timing_offset_ms,
    duration_mod, chord_voicing, harmony_note, harmony_interval,
    start_slot, duration_slots, effective_voicing) (

  // Clear the events array
  slot = 0;
  loop(64,
    phrase_events[slot] = 0;
    phrase_velocities[slot] = 0;
    phrase_note_offs[slot] = -1;  // -1 = release when next note starts
    phrase_pedal[slot] = 1;       // Default pedal down
    phrase_timing_offset[slot] = 0;  // No timing offset
    phrase_duration_mod[slot] = 1.0; // Full duration (1.0 = 100%)
    phrase_harmony_note[slot] = 0;   // No harmony note
    slot += 1;
  );

  // Initialize harmonic mud tracker for pedal scheduling
  sched_mud = 0;

  // Get parameters
  density = max(0, min(1, slider7));
  vel_range = slider17 - slider16;

  // Store original context to restore later
  original_chord_idx = current_chord_idx;
  switched_context = 0;

  // Schedule each note
  slot = 0;
  prev_note = -1;
  i = 0;
  max_slot_used = 0;
  loop(phrase_length,
    // Context Switching: Check if we've crossed the chord boundary
    current_beat_time = slot * 0.5;
    (sched_target_next_chord && current_beat_time >= sched_boundary_beats) ? (
      !switched_context ? (
        current_chord_idx = sched_next_chord_idx;
        build_chord_tones();
        switched_context = 1;
      );
    );

    note = phrase_notes[i];
    
    // Add to history to prevent immediate repetition in future phrases
    add_to_history(note);

    // Place this note at current slot (all notes play)
    phrase_events[slot] = note;
    max_slot_used = max(max_slot_used, slot);

    // Calculate velocity based on melodic direction
    prev_note >= 0 ? (
      note_diff = note - prev_note;
      note_diff > 0 ? (
        // Upward phrase: increase velocity incrementally
        velocity = phrase_velocities[slot - 1] + 3 + rand() * 2;
        velocity = max(slider16, min(slider17, velocity));
      ) : note_diff < 0 ? (
        // Downward phrase: decrease velocity incrementally
        velocity = phrase_velocities[slot - 1] - 3 - rand() * 2;
        velocity = max(slider16, min(slider17, velocity));
      ) : (
        // Repeated note: maintain velocity with slight variation
        velocity = phrase_velocities[slot - 1] + (rand() * 4 - 2);
        velocity = max(slider16, min(slider17, velocity));
      );
    ) : (
      last_phrase_end_velocity > 0 ? (
        velocity = last_phrase_end_velocity + (rand() * 30 - 15);
        velocity = max(slider16, min(slider17, velocity));
      ) : (
        velocity = slider16 + rand() * vel_range;
      );
    );
    phrase_velocities[slot] = max(1, min(127, floor(velocity)));

    // === CHORD VOICING (harmony notes) ===
    chord_voicing = slider19;
    chord_voicing > 0 ? (
      note_class = note % 12;
      chord_tone_idx = get_chord_tone_index(note_class);

      // Only add harmony for chord tones, based on probability
      (chord_tone_idx >= 0 && rand() < chord_voicing) ? (
        // Pick harmony interval: 3rd only (3-4 semitones up or down)
        harmony_interval = 3 + floor(rand() * 2);  // 3-4 semitones

        // Calculate harmony note (try up first)
        harmony_note = note + harmony_interval;
        harmony_note = max(0, min(127, harmony_note));

        // Verify it's still a chord tone (within an octave)
        (harmony_note % 12) == current_chord_tones[0] ||
        (harmony_note % 12) == current_chord_tones[1] ||
        (harmony_note % 12) == current_chord_tones[2] ||
        (harmony_note % 12) == current_chord_tones[3] ? (
          phrase_harmony_note[slot] = harmony_note;
        ) : (
          // Try a 3rd down instead
          harmony_note = note - 3 - floor(rand() * 2);
          harmony_note = max(0, min(127, harmony_note));
          (harmony_note % 12) == current_chord_tones[0] ||
          (harmony_note % 12) == current_chord_tones[1] ||
          (harmony_note % 12) == current_chord_tones[2] ||
          (harmony_note % 12) == current_chord_tones[3] ? (
            phrase_harmony_note[slot] = harmony_note;
          );
        );
      );
    );

    // === HUMANIZATION (timing feel) ===
    humanize = slider18;
    humanize > 0 ? (
      // Base timing offset: random variation scaled by humanize amount
      base_offset_ms = (rand() * 2 - 1) * HUMANIZE_MAX_MS * humanize;

      // Velocity correlation: softer notes arrive later, louder notes on-beat
      vel_normalized = (velocity - slider16) / max(1, vel_range);  // 0 to 1
      vel_timing_shift = (1 - vel_normalized) * HUMANIZE_VEL_CORRELATION * HUMANIZE_MAX_MS * humanize;

      // Combine offsets (keep positive = delay only for musical feel)
      timing_offset_ms = base_offset_ms + vel_timing_shift;
      timing_offset_ms = max(0, min(HUMANIZE_MAX_MS * 2, timing_offset_ms));

      // Convert ms to samples
      phrase_timing_offset[slot] = floor(timing_offset_ms * srate / 1000);

      // Duration variation
      rand() < (HUMANIZE_STACCATO_PROB * humanize) ? (
        // Staccato: 40-70% of full duration
        phrase_duration_mod[slot] = 0.4 + rand() * 0.3;
      ) : (
        // Normal variation: 85-115% of full duration
        duration_mod = 1.0 + (rand() * 2 - 1) * HUMANIZE_DURATION_VAR * humanize;
        phrase_duration_mod[slot] = max(0.5, min(1.15, duration_mod));
      );
    ) : (
      phrase_timing_offset[slot] = 0;
      phrase_duration_mod[slot] = 1.0;
    );

    // === CHORD TONE EXTENSION & PEDAL LOGIC (only when pedal modeling enabled) ===
    slider20 == 1 ? (
      note_class = note % 12;
      chord_tone_idx = get_chord_tone_index(note_class);

      chord_tone_idx >= 0 ? (
        // This is a chord tone - calculate extension probability
        sustain_prob = get_sustain_probability(chord_tone_idx);

        // Adjust for phrase position (0 to 1)
        position_factor = i / phrase_length;
        position_factor < 0.3 ? (
          sustain_prob += SUSTAIN_EARLY_BONUS;  // Early in phrase: more sustain
        ) : position_factor > 0.7 ? (
          sustain_prob -= SUSTAIN_LATE_PENALTY; // Late in phrase: less sustain
        );

        // Adjust for density (high density = less sustain)
        density_factor = 1.0 - (density * 0.4);
        sustain_prob *= density_factor;

        // Clamp probability
        sustain_prob = max(0, min(0.95, sustain_prob));

        // Roll for extension
        rand() < sustain_prob ? (
          // Calculate max extension (don't extend past phrase end)
          max_extension = phrase_slot_count - slot - 1;
          max_extension = max(SUSTAIN_MIN_EXTENSION, max_extension);

          // Late in phrase: cap extension
          position_factor > 0.7 ? (
            max_extension = min(max_extension, SUSTAIN_LATE_MAX_SLOTS);
          );

          // Apply density factor to max extension
          max_extension = floor(max_extension * density_factor);
          max_extension = max(SUSTAIN_MIN_EXTENSION, max_extension);

          // Random extension with bias toward shorter (rand * rand)
          extension_slots = SUSTAIN_MIN_EXTENSION + floor(rand() * rand() * (max_extension - SUSTAIN_MIN_EXTENSION));

          // Store the end slot for this note
          phrase_note_offs[slot] = slot + extension_slots;
        );

        // Chord tones reduce harmonic mud
        sched_mud *= PEDAL_CHORD_TONE_CLEAR;
      ) : (
        // Not a chord tone
        is_scale_tone(note_class) ? (
          sched_mud += PEDAL_SCALE_TONE_MUD;
        ) : (
          sched_mud += PEDAL_PASSING_TONE_MUD;
        );
      );

      // === PEDAL SCHEDULING ===
      // If mud exceeds threshold, schedule pedal lift
      sched_mud >= PEDAL_DISSONANCE_THRESHOLD ? (
        // Lift pedal at this slot
        phrase_pedal[slot] = 0;
        // Reset mud (pedal cleared the dissonance)
        sched_mud = 0;
      );
    );

    prev_note = note;

    // Calculate rest duration AFTER this note based on its importance
    // Important notes (root/5th/3rd) get longer rests after them
    rest_weight = get_note_selection_weight(note);
    rest_multiplier = rest_weight / CHORD_ROOT_WEIGHT;
    rest_emphasis = 0.5 + rest_multiplier * 1.5;  // Root=2.0, Fifth=1.125, Third=0.75, Scale=0.6, Passing=0.525

    start_slot = slot;

    // Decide timing for next note based on note importance and density
    (i < phrase_length - 1 && slot < 70) ? (
      // Higher rest_emphasis = longer gap after this note
      rand() < (density * (1.0 / max(0.75, rest_emphasis))) ? (
        // Next note comes as 8th note (next slot) - less likely for important notes
        slot += 1;
      ) : (
        // Next note on quarter boundary (skip to even slot)
        // LEGATO vs REST: High density = Sustain (Legato), Low density = Rest (Silence)
        rand() < density ? (
          phrase_events[slot + 1] = note;
          phrase_velocities[slot + 1] = -1;
        );
        
        slot += 1;
        (slot % 2 == 1) ? slot += 1;  // Ensure even slot for quarter note
        
        // Insert extra rest space based on density (inverse relationship)
        // Lower density = higher chance of gaps between notes. Scale by rest_emphasis.
        (rand() < (1.0 - density) * rest_emphasis * 0.6) ? (
          // If adding extra rest, clear the sustain we just added (if any)
          phrase_events[slot - 1] = 0;
          phrase_velocities[slot - 1] = 0;
          
          slot += 2;  // Add full quarter note of extra space
        );
      );
    );

    // Last note logic: Extend duration for better resolution
    (i == phrase_length - 1) ? (
      // Default to Quarter Note (2 slots)
      (slot < 63) ? (
        phrase_events[slot + 1] = note;
        phrase_velocities[slot + 1] = -1; // Sustain
        slot += 1;
        max_slot_used = max(max_slot_used, slot);
        
        // If stable note (Root/5th), extend to Half Note (4 slots)
        (rest_emphasis > 1.1 && slot < 62) ? (
          phrase_events[slot + 1] = note;
          phrase_velocities[slot + 1] = -1;
          phrase_events[slot + 2] = note;
          phrase_velocities[slot + 2] = -1;
          slot += 2;
          max_slot_used = max(max_slot_used, slot);
        );
      );
    );

    // === CHORD VOICING (harmony notes) ===
    // Moved here to base probability on note duration
    duration_slots = slot - start_slot;
    chord_voicing = slider19;
    chord_voicing > 0 ? (
      // Boost probability for longer notes (duration >= 2 slots / Quarter note)
      // Reduce for short passing notes
      effective_voicing = (duration_slots >= 2) ? min(1.0, chord_voicing * 1.5 + 0.1) : (chord_voicing * 0.5);

      note_class = note % 12;
      chord_tone_idx = get_chord_tone_index(note_class);

      // Only add harmony for chord tones, based on probability
      (chord_tone_idx >= 0 && rand() < effective_voicing) ? (
        // Pick harmony interval: 3rd only (3-4 semitones up or down)
        harmony_interval = 3 + floor(rand() * 2);  // 3-4 semitones

        // Calculate harmony note (try up first)
        harmony_note = note + harmony_interval;
        harmony_note = max(0, min(127, harmony_note));

        // Verify it's still a chord tone (within an octave)
        (harmony_note % 12) == current_chord_tones[0] ||
        (harmony_note % 12) == current_chord_tones[1] ||
        (harmony_note % 12) == current_chord_tones[2] ||
        (harmony_note % 12) == current_chord_tones[3] ? (
          phrase_harmony_note[start_slot] = harmony_note;
        ) : (
          // Try a 3rd down instead
          harmony_note = note - 3 - floor(rand() * 2);
          harmony_note = max(0, min(127, harmony_note));
          (harmony_note % 12) == current_chord_tones[0] ||
          (harmony_note % 12) == current_chord_tones[1] ||
          (harmony_note % 12) == current_chord_tones[2] ||
          (harmony_note % 12) == current_chord_tones[3] ? (
            phrase_harmony_note[start_slot] = harmony_note;
          );
        );
      );
    );

    i += 1;
  );

  // Store final velocity for next phrase continuity
  last_phrase_end_velocity = velocity;

  // Restore original context if we switched
  switched_context ? (
    current_chord_idx = original_chord_idx;
    build_chord_tones();
  );

  // Record total slots used (count = highest slot index + 1)
  phrase_slot_count = max_slot_used + 1;

  // Calculate rest after this phrase (in 8th notes since countdown is now per-8th)
  slider14 == 1 ? (
    // Continuous mode: minimal rest (0-1 eighth notes) to match inner phrase timing
    phrase_rest_after = floor(rand() * 2);
  ) : (
    rest_scale = 1 - density;
    sparse_boost = 1 + rest_scale * 1.5;
    min_rest = ceil(REST_MIN_BASE * sparse_boost * 2);  // Convert to 8ths
    max_rest = ceil(REST_MAX_BASE * sparse_boost * 2);  // Convert to 8ths
    min_rest = max(REST_MIN_FLOOR * 2, min_rest);
    max_rest = min(REST_MAX_CEILING * 2, max_rest);
    max_rest = max(min_rest, max_rest);
    phrase_rest_after = min_rest + floor(rand() * (max_rest - min_rest + 1));
  );
);

// Nudge the final note toward the nearest measure downbeat when close (bias, not absolute)
function bias_phrase_end_to_downbeat() local(i, last_slot, slot_idx, note, vel,
    chord_pos_beats, phrase_end_rel_beats, target_abs_beats, nearest_downbeat,
    diff_beats, desired_rel_beats, desired_slot) (

    // Find last occupied slot (highest index with a note)
    last_slot = -1;
    i = 0;
    loop(64,
      slot_idx = 63 - i;
      phrase_events[slot_idx] > 0 ? last_slot = (last_slot < 0 ? slot_idx : last_slot);
      i += 1;
    );

    (last_slot >= 0) ? (
      // Use current chord position for live phrases; start-of-chord for background build
      chord_pos_beats = prog_beat_counter;
      phrase_end_rel_beats = last_slot * 0.5;  // slots are 8ths
      target_abs_beats = chord_pos_beats + phrase_end_rel_beats;

      // Nearest measure downbeat (every 4 beats)
      nearest_downbeat = floor((target_abs_beats / 4) + 0.5) * 4;
      diff_beats = abs(target_abs_beats - nearest_downbeat);

      (diff_beats <= DOWNBEAT_SNAP_WINDOW && rand() < DOWNBEAT_END_BIAS) ? (
        desired_rel_beats = nearest_downbeat - chord_pos_beats;
        desired_slot = floor(desired_rel_beats * 2 + 0.5);
        desired_slot = max(0, min(63, desired_slot));

        (desired_slot != last_slot && phrase_velocities[last_slot] != -1) ? (
          note = phrase_events[last_slot];
          vel = phrase_velocities[last_slot];
          phrase_events[last_slot] = 0;
          phrase_velocities[last_slot] = 0;
          phrase_events[desired_slot] = note;
          phrase_velocities[desired_slot] = vel;
          phrase_slot_count = max(phrase_slot_count, desired_slot + 1);
          // Increase rest after phrase to emphasize the downbeat landing
          slider14 == 0 ? (
            phrase_rest_after += DOWNBEAT_REST_BONUS;
          );
        );
      );
    );
);

// Convert octave slider (0-5 = C1-C6) to MIDI base note
// C1 = MIDI 24, C2 = 36, C3 = 48, C4 = 60, C5 = 72, C6 = 84
function get_base_note() (
  (slider3 + 1) * 12 + 12;  // slider3=0 -> 24 (C1), slider3=3 -> 60 (C4)
);

// ============================================
// PHRASE GENERATION HELPERS
// ============================================

// Helper: Initialize phrase boundaries (hard and soft)
function init_phrase_boundaries() local(base_note, top_note) (
  base_note = get_base_note();
  top_note = base_note + (slider4 * 12);
  
  // Store in global temp variables
  temp_base_note = base_note;
  temp_top_note = top_note;
  temp_soft_base = base_note - SOFT_BOUNDARY_EXTENSION;
  temp_soft_top = top_note + SOFT_BOUNDARY_EXTENSION;
);

// Pick an ending note: weighted toward chord tones (95%), scale tones (4%), passing tones (1%)
function pick_phrase_endpoint() local(base_note, top_note, midi_note, note_class, weight, total_weight, random_val, cumulative, idx, selected, range) (
  base_note = get_base_note();
  top_note = base_note + (slider4 * 12);
  
  // Extend boundaries for soft limits
  soft_base = base_note - SOFT_BOUNDARY_EXTENSION;
  soft_top = top_note + SOFT_BOUNDARY_EXTENSION;

  num_available = 0;
  total_weight = 0;
  
  // Use loop instead of while for JSFX compatibility
  // Use soft boundaries for endpoint selection
  midi_note = soft_base;
  range = soft_top - soft_base + 1;
  idx = 0;
  loop(range,
    (midi_note <= soft_top) ? (
      // Compute selection weight for this MIDI note
      weight = get_note_selection_weight(midi_note);
      
      available_notes[num_available] = midi_note;
      note_weights[num_available] = weight;
      total_weight += weight;
      num_available += 1;
      midi_note += 1;
    );
    idx += 1;
  );
  
  // Normalize weights
  idx = 0;
  loop(num_available,
    note_weights[idx] = note_weights[idx] / total_weight;
    idx += 1;
  );
  
  // Weighted random selection
  random_val = rand();
  cumulative = 0;
  selected = available_notes[0];
  idx = 0;
  done = 0;
  loop(num_available,
    done ? (
      idx = num_available;  // Skip remaining iterations
    ) : (
      cumulative += note_weights[idx];
      random_val <= cumulative ? (
        selected = available_notes[idx];
        done = 1;
      );
      idx += 1;
    );
  );
  
  // Safety: if selected is still 0 or invalid, pick a random note from available
  (selected < soft_base || selected > soft_top) ? (
    selected = available_notes[floor(rand() * num_available)];
  );
  
  selected;
);

// Helper: Pick and validate endpoint, ensuring it's a chord tone
function pick_and_validate_endpoint() local(retry_count) (
  // Consume random values to break cycling patterns
  retry_count = 0;
  loop(5 + (phrase_build_counter % 7),
    rand();
    retry_count += 1;
  );
  
  // Pick ending note
  phrase_end_note = pick_phrase_endpoint();
  
  // Avoid repeating same endpoint consecutively
  retry_count = 0;
  loop(8,
    (phrase_end_note == last_endpoint_note) ? (
      phrase_end_note = pick_phrase_endpoint();
      retry_count += 1;
    ) : (
      retry_count = 10;  // break
    );
  );
  last_endpoint_note = phrase_end_note;
  
  // Ensure ending note is a chord tone - retry if not
  loop(10,
    !is_chord_tone(phrase_end_note % 12) ? (
      phrase_end_note = pick_phrase_endpoint();
    ) : (
      retry_count = 10;  // break
    );
  );
  
  // Return success if chord tone found
  is_chord_tone(phrase_end_note % 12);
);

// Helper: Determine phrase direction based on available room
function determine_phrase_direction() local(room_above, room_below, semitones_needed, direction, random_direction) (
  room_above = temp_top_note - phrase_end_note;
  room_below = phrase_end_note - temp_base_note;
  
  // Estimate semitones needed (roughly 2 per scale step)
  semitones_needed = phrase_length * 2;
  
  // Pick direction based on available room
  room_below >= semitones_needed ? (
    room_above >= semitones_needed ? (
      // Both directions work - pick randomly
      random_direction = rand();
      direction = random_direction < 0.5 ? 1 : -1;
    ) : (
      // Only room below - must go UP
      direction = 1;
    );
  ) : (
    // Not enough room below - must go DOWN
    direction = -1;
  );
  
  direction;
);

// Helper: Build temporary array of scale notes in extended range
function build_temp_scale_array() local(midi_note, note_class, temp_count) (
  temp_scale_notes = 800;
  temp_count = 0;
  
  // Fill with scale notes in extended range (soft boundaries)
  midi_note = temp_soft_base;
  loop(temp_soft_top - temp_soft_base + 1,
    note_class = midi_note % 12;
    is_scale_tone(note_class) ? (
      temp_scale_notes[temp_count] = midi_note;
      temp_count += 1;
    );
    midi_note += 1;
  );
  
  temp_count;  // Return count
);

// Helper: Validate that we have enough scale notes to build a phrase
function validate_scale_array(temp_count) (
  // Just need enough notes to work with
  temp_count >= 7 ? 1 : 0;
);

// Helper: Find index of a MIDI note in the temp_scale_notes array
function find_scale_index(midi_note, temp_count) local(i, found_idx) (
  found_idx = -1;
  i = 0;
  loop(temp_count,
    temp_scale_notes[i] == midi_note ? found_idx = i;
    i += 1;
  );
  found_idx;
);

// Helper: Find nearest scale note index to a target MIDI note
function find_nearest_scale_index(target_midi, temp_count) local(i, best_idx, best_dist, dist) (
  best_idx = 0;
  best_dist = 999;
  i = 0;
  loop(temp_count,
    dist = abs(temp_scale_notes[i] - target_midi);
    dist < best_dist ? (
      best_dist = dist;
      best_idx = i;
    );
    i += 1;
  );
  best_idx;
);

// Clamp a candidate note so jumps never exceed 7 semitones
function clamp_jump(prev_note, candidate_note, temp_count)
    local(diff, direction, target_note, idx) (
  (prev_note < 0) ? candidate_note : (
    diff = abs(candidate_note - prev_note);
    diff <= 7 ? (
      candidate_note;
    ) : (
      direction = candidate_note >= prev_note ? 1 : -1;
      target_note = prev_note + direction * 7;
      idx = find_nearest_scale_index(target_note, temp_count);
      temp_scale_notes[idx];
    );
  );
);

// Phase 1: Exploration - free movement with direction changes
function build_exploration_phase(start_idx, num_notes, temp_count)
    local(i, note_idx, current_direction, steps_since_dir_change, prev_midi_note,
          midi_note, note_class, distance_from_top, distance_from_bottom,
          near_top_boundary, near_bottom_boundary, min_steps_between,
          dir_change_prob, skip_amount, use_repeat, prev_note_type, curr_note_type,
          consecutive_repeats, consecutive_skips, last_skip_size) (

  note_idx = start_idx;
  current_direction = phrase_direction;
  steps_since_dir_change = 0;
  prev_midi_note = -1;
  prev_note_type = 0;
  consecutive_repeats = 0;
  consecutive_skips = 0;
  last_skip_size = 1;

  i = 0;
  loop(num_notes,
    // Bounds check
    note_idx = max(0, min(temp_count - 1, note_idx));

    midi_note = temp_scale_notes[note_idx];
    note_class = midi_note % 12;

    // Check proximity to boundaries
    distance_from_top = temp_soft_top - midi_note;
    distance_from_bottom = midi_note - temp_soft_base;
    near_top_boundary = distance_from_top <= 3;
    near_bottom_boundary = distance_from_bottom <= 3;

    // Force direction change at boundaries
    near_top_boundary && current_direction > 0 ? (
      current_direction = -1;
      steps_since_dir_change = 0;
    );
    near_bottom_boundary && current_direction < 0 ? (
      current_direction = 1;
      steps_since_dir_change = 0;
    );

    // Random direction changes based on phrase length
    !near_top_boundary && !near_bottom_boundary ? (
      phrase_length <= 8 ? (
        min_steps_between = 4 + floor(rand() * 3);
        dir_change_prob = 0.2;
      ) : phrase_length <= 14 ? (
        min_steps_between = 3 + floor(rand() * 2);
        dir_change_prob = 0.3;
      ) : (
        min_steps_between = 2 + floor(rand() * 2);
        dir_change_prob = 0.4;
      );

      steps_since_dir_change >= min_steps_between ? (
        rand() < dir_change_prob ? (
          current_direction = -current_direction;
          steps_since_dir_change = 0;
        );
      );
    );

    // Determine note type
    curr_note_type = is_chord_tone(note_class) ? 1 : 2;

    // Check for repeat (not on first note, and limit consecutive repeats)
    use_repeat = 0;
    (i > 0 && prev_midi_note > 0 && consecutive_repeats < MAX_CONSECUTIVE_REPEATS) ? (
      prev_note_type == 1 ? (
        rand() < REPEAT_CHORD_PROB ? use_repeat = 1;
      ) : prev_note_type == 2 ? (
        rand() < REPEAT_SCALE_PROB ? use_repeat = 1;
      );
    );

    use_repeat ? (
      phrase_notes[i] = prev_midi_note;
      consecutive_repeats += 1;
      consecutive_skips = 0;  // Reset skip counter on repeat
    ) : (
      // Clamp jump size before committing the note
      midi_note = i > 0 ? clamp_jump(prev_midi_note, midi_note, temp_count) : midi_note;
      
      // Check if we are repeating despite not choosing to (e.g. boundary clamping)
      (i > 0 && midi_note == prev_midi_note) ? (
        consecutive_repeats += 1;
        
        // If we've hit the limit, force a change
        consecutive_repeats > MAX_CONSECUTIVE_REPEATS ? (
           // Find current index and move 1 step away
           note_idx = find_nearest_scale_index(midi_note, temp_count);
           note_idx == 0 ? note_idx += 1 : note_idx -= 1;
           midi_note = temp_scale_notes[note_idx];
           consecutive_repeats = 0;
        );
      ) : (
        consecutive_repeats = 0;
      );

      note_idx = find_nearest_scale_index(midi_note, temp_count);
      note_class = midi_note % 12;

      phrase_notes[i] = midi_note;
      prev_midi_note = midi_note;
      prev_note_type = curr_note_type;

      // Advance with random skip, but limit consecutive large skips
      consecutive_skips >= MAX_CONSECUTIVE_SKIPS ? (
        // Force a step of 1 after too many large skips
        skip_amount = 1;
        consecutive_skips = 0;
      ) : (
        skip_amount = 1 + floor(rand() * rand() * MAX_JUMP);
      );

      // Track consecutive skips >= 2 (thirds and larger sound like arpeggios)
      skip_amount >= 2 ? (
        consecutive_skips += 1;
      ) : (
        consecutive_skips = 0;
      );

      last_skip_size = skip_amount;
      note_idx += current_direction * skip_amount;
    );

    steps_since_dir_change += 1;
    i += 1;
  );

  // Return the final note_idx for resolution phase to use
  note_idx;
);

// Phase 2: Resolution - guided movement toward the endpoint
function build_resolution_phase(start_note_idx, end_note_idx, start_phrase_idx, num_notes, temp_count)
  local(i, note_idx, target_idx, notes_remaining, distance_to_target,
      step_direction, midi_note, note_class, should_step_toward,
      skip_amount, approach_from_below, penultimate_idx,
      last_step_size, consecutive_large_steps, prev_resolution_note,
      prev_resolution_midi) (

  // Decide approach direction for final note
  approach_from_below = rand() < APPROACH_FROM_BELOW_PROB;

  note_idx = start_note_idx;
  target_idx = end_note_idx;
  consecutive_large_steps = 0;
  last_step_size = 1;
  prev_resolution_note = -1;
    prev_resolution_midi = -1;

  i = 0;
  loop(num_notes,
    notes_remaining = num_notes - i;

    // Bounds check
    note_idx = max(0, min(temp_count - 1, note_idx));

    // Last note: force to endpoint
    notes_remaining == 1 ? (
      phrase_notes[start_phrase_idx + i] = phrase_end_note;
    ) : (
      // Second-to-last note: set up the approach
      notes_remaining == 2 ? (
        // Position one step away from target in the chosen approach direction
        approach_from_below ? (
          penultimate_idx = max(0, target_idx - 1);
        ) : (
          penultimate_idx = min(temp_count - 1, target_idx + 1);
        );
        note_idx = penultimate_idx;
        midi_note = temp_scale_notes[note_idx];
        midi_note = prev_resolution_midi >= 0 ? clamp_jump(prev_resolution_midi, midi_note, temp_count) : midi_note;
        note_idx = find_nearest_scale_index(midi_note, temp_count);
        phrase_notes[start_phrase_idx + i] = midi_note;
        prev_resolution_midi = midi_note;
        prev_resolution_note = note_idx;
      ) : (
        // Earlier resolution notes: progressively move toward target
        distance_to_target = target_idx - note_idx;

        // Determine if we should step toward target
        should_step_toward = rand() < RESOLUTION_STEP_BIAS;

        // Calculate direction needed to reach target
        distance_to_target > 0 ? (
          step_direction = 1;
        ) : distance_to_target < 0 ? (
          step_direction = -1;
        ) : (
          step_direction = 0;
        );

        // If we're far from target or should step toward it, move in that direction
        (abs(distance_to_target) > RESOLUTION_START_DISTANCE || should_step_toward) ? (
          // Limit consecutive skips > 1 to prevent arpeggio patterns (thirds sound like arpeggios)
          consecutive_large_steps >= MAX_CONSECUTIVE_SKIPS ? (
            // Force stepwise motion after too many skips
            skip_amount = 1;
            consecutive_large_steps = 0;
          ) : (
            // Heavily favor stepwise motion (85% step of 1, 15% step of 2)
            skip_amount = rand() < 0.85 ? 1 : 2;
          );
          // Don't overshoot the target area
          skip_amount = min(skip_amount, max(1, abs(distance_to_target) - 2));
          note_idx += step_direction * skip_amount;

          // Track consecutive non-stepwise motion (skips >= 2 count as "large")
          skip_amount >= 2 ? (
            consecutive_large_steps += 1;
          ) : (
            consecutive_large_steps = 0;
          );
        ) : (
          // Close to target, allow small wandering or hold position
          consecutive_large_steps = 0;  // Reset on wander
          rand() < 0.4 ? (
            // Sometimes stay on same note for a beat
            note_idx = note_idx;
          ) : rand() < 0.5 ? (
            note_idx += (rand() < 0.5 ? 1 : -1);
          );
        );

        // Bounds check
        note_idx = max(0, min(temp_count - 1, note_idx));

        midi_note = temp_scale_notes[note_idx];
        midi_note = prev_resolution_midi >= 0 ? clamp_jump(prev_resolution_midi, midi_note, temp_count) : midi_note;
        note_idx = find_nearest_scale_index(midi_note, temp_count);
        phrase_notes[start_phrase_idx + i] = midi_note;
        last_step_size = abs(note_idx - (i > 0 ? prev_resolution_note : note_idx));
        prev_resolution_note = note_idx;
        prev_resolution_midi = midi_note;
      );
    );

    i += 1;
  );
);

// Main phrase builder: Two-phase approach (exploration + resolution)
function build_phrase_notes(direction, temp_count)
    local(exploration_notes, resolution_notes, start_idx, end_idx,
          final_exploration_idx, current_note_idx, max_resolution_distance,
          exploration_distance) (

  // Calculate phase lengths
  exploration_notes = floor(phrase_length * EXPLORATION_RATIO);
  exploration_notes = max(1, exploration_notes);  // At least 1 exploration note
  resolution_notes = phrase_length - exploration_notes;
  resolution_notes = max(1, resolution_notes);    // At least 1 resolution note

  // Ensure we don't exceed phrase length
  (exploration_notes + resolution_notes) > phrase_length ? (
    exploration_notes = phrase_length - resolution_notes;
  );

  // Find endpoint index in scale array
  end_idx = find_scale_index(phrase_end_note, temp_count);
  end_idx < 0 ? (
    // Endpoint not exactly on scale, find nearest
    end_idx = find_nearest_scale_index(phrase_end_note, temp_count);
  );

  // Calculate max distance exploration can go based on resolution notes available
  // Resolution can cover ~1.5 scale steps per note with current constraints (mostly stepwise)
  // We want exploration to end within a distance that resolution can comfortably cover
  max_resolution_distance = floor(resolution_notes * 1.3);

  // Calculate starting position - don't start farther than resolution can handle
  // Use the smaller of: phrase_length * 0.8 OR max_resolution_distance
  exploration_distance = min(floor(phrase_length * 0.8), max_resolution_distance);
  start_idx = end_idx - (direction * exploration_distance);
  start_idx = max(0, min(temp_count - 1, start_idx));

  // Phase 1: Exploration
  final_exploration_idx = build_exploration_phase(start_idx, exploration_notes, temp_count);

  // Phase 2: Resolution - start from where exploration ended
  // But first, check if exploration ended too far from target
  // If so, nudge it closer to ensure smooth resolution
  current_note_idx = max(0, min(temp_count - 1, final_exploration_idx));

  // Safety check: if we're too far from target for the remaining notes, move closer
  abs(current_note_idx - end_idx) > (resolution_notes * 2) ? (
    // We're too far - move starting point closer to target
    // Leave enough room for resolution to have musical movement
    direction > 0 ? (
      current_note_idx = max(0, end_idx - resolution_notes - 1);
    ) : (
      current_note_idx = min(temp_count - 1, end_idx + resolution_notes + 1);
    );
  );

  build_resolution_phase(current_note_idx, end_idx, exploration_notes, resolution_notes, temp_count);

  1;  // Return success
);

// Build entire phrase by walking scale from calculated start to pre-selected end
function build_phrase_from_endpoint() local(max_phrase, min_phrase, direction, temp_count, success, target_next_chord, saved_chord_idx, next_chord_idx, valid_endpoint) (
  phrase_build_counter += 1;

  // Step 1: Initialize boundaries
  init_phrase_boundaries();

  // Step 2: Determine phrase length FIRST (so we know if we cross chord boundary)
  max_phrase = min(slider6, slider4 * 7);
  min_phrase = min(slider5, max_phrase);
  random_length = rand();
  phrase_length = min_phrase + floor(random_length * (max_phrase - min_phrase + 1));

  // Step 3: Check if we cross chord boundary and should target next chord
  target_next_chord = 0;
  rand() < CHORD_BOUNDARY_RESPECT_PROB ? (
    // Truncate to fit in current chord (moved from build_phrase_notes)
    phrase_length = min(phrase_length, max(2, (prog_beats_until_change * 2)));
  ) : (
    // Allowed to cross. If phrase is long enough, target next chord
    (phrase_length * 0.5 > prog_beats_until_change) ? target_next_chord = 1;
  );

  // Step 4: Pick and validate endpoint
  // If targeting next chord, temporarily switch context
  target_next_chord ? (
    saved_chord_idx = current_chord_idx;
    next_chord_idx = (prog_chord_index + 1) % slider8;
    current_chord_idx = prog_chords[next_chord_idx];
    build_chord_tones();
  );
  
  // Prepare scheduling context globals
  sched_target_next_chord = target_next_chord;
  sched_next_chord_idx = prog_chords[(prog_chord_index + 1) % slider8];  // Store chord VALUE, not index
  sched_boundary_beats = prog_beats_until_change;

  valid_endpoint = pick_and_validate_endpoint();

  target_next_chord ? (
    current_chord_idx = saved_chord_idx;
    build_chord_tones();
  );

  valid_endpoint ? (
    // Endpoint is valid chord tone, continue

    // Step 5: Determine direction (which way to start exploring)
    direction = determine_phrase_direction();
    phrase_direction = direction;

    // Step 6: Build temp scale array
    temp_count = build_temp_scale_array();

    // Step 7: Validate we have enough notes
    validate_scale_array(temp_count) ? (

      // Step 8: Build phrase using two-phase approach
      // Phase 1 (exploration) + Phase 2 (resolution to endpoint)
      success = build_phrase_notes(direction, temp_count);

      // Step 9: Schedule events and finalize
      success ? (
        schedule_phrase_events();
        bias_phrase_end_to_downbeat();
        phrase_active = 1;
        phrase_slot_index = 0;
        phrase_start_beat = -1;  // Will be set on first playback tick
        phrase_built_for_chord = current_chord_idx;  // Store which chord this phrase was built for
      ) : (
        // Build failed
        phrase_active = 0;
        between_phrase_rest = 1;
      );
    ) : (
      // Not enough scale notes
      phrase_active = 0;
      between_phrase_rest = 1;
    );
  ) : (
    // Failed to find chord tone endpoint
    phrase_active = 0;
    between_phrase_rest = 1;
  );
);

function add_phrase_to_viz() local(i, note, start_time, vel, duration, offset) (
  i = 0;
  loop(phrase_slot_count,
    note = phrase_events[i];
    vel = phrase_velocities[i];

    // Only process note starts (velocity > 0). Ignore sustains (-1) and rests (0).
    (note > 0 && vel > 0) ? (
      // Note plays when current_eighth boundary is crossed (at phrase_start_beat + slot * 0.5)
      start_time = phrase_start_beat + (i * 0.5);
      duration = 0.5;

      // Look ahead for sustains (velocity == -1) to combine into one block
      offset = 1;
      while (i + offset < phrase_slot_count && phrase_events[i+offset] == note && phrase_velocities[i+offset] == -1) (
        duration += 0.5;
        offset += 1;
      );

      viz_buffer_pitch[viz_head] = note;
      viz_buffer_start[viz_head] = start_time;
      viz_buffer_len[viz_head] = duration;
      viz_head = (viz_head + 1) % viz_buffer_size;
    );
    i += 1;
  );
);

// ============================================
// MIDI OUTPUT FUNCTIONS
// ============================================

function send_note_on(note, vel, timing_offset) (
  midisend(timing_offset, $x90 + (slider22 > 0 ? slider22 - 1 : 0), note, vel);
  note_playing = note;
);

function send_note_off(offset) (
  note_playing > 0 ? (
    midisend(offset, $x80 + (slider22 > 0 ? slider22 - 1 : 0), note_playing, 0);
    note_playing = 0;
  );
);

function send_harmony_note_off(offset) (
  harmony_note_playing > 0 ? (
    midisend(offset, $x80 + (slider22 > 0 ? slider22 - 1 : 0), harmony_note_playing, 0);
    harmony_note_playing = 0;
  );
);

// Queue a note to be sent at an absolute sample position
// is_harmony: 0 = main note, 1 = harmony note
function queue_pending_note(note, vel, target_sample, is_harmony) (
  pending_note_count < 16 ? (  // Max 16 pending notes
    pending_note_pitch[pending_note_count] = note;
    pending_note_vel[pending_note_count] = vel;
    pending_note_sample[pending_note_count] = target_sample;
    pending_note_is_harmony[pending_note_count] = is_harmony;
    pending_note_count += 1;
  );
);

// Process any pending notes that should play in this block
function process_pending_notes() local(i, j, offset, block_end, is_harm) (
  block_end = current_sample_pos + samplesblock;

  i = 0;
  while (i < pending_note_count) (
    // Check if this note should play within this block
    (pending_note_sample[i] >= current_sample_pos && pending_note_sample[i] < block_end) ? (
      // Calculate offset within this block
      offset = pending_note_sample[i] - current_sample_pos;
      offset = max(0, min(samplesblock - 1, offset));

      // Send note-off for previous note of same type before playing new one
      is_harm = pending_note_is_harmony[i];
      is_harm ? (
        // Turn off previous harmony note first
        harmony_note_playing > 0 ? (
          midisend(offset > 0 ? offset - 1 : 0, $x80 + (slider23 > 0 ? slider23 - 1 : 0), harmony_note_playing, 0);
        );
      ) : (
        // Turn off previous main note first (if not held)
        note_playing > 0 && !is_being_held(note_playing) ? (
          midisend(offset > 0 ? offset - 1 : 0, $x80 + (slider23 > 0 ? slider23 - 1 : 0), note_playing, 0);
        );
      );

      // Send the note-on
      midisend(offset, $x90 + (slider23 > 0 ? slider23 - 1 : 0),
               pending_note_pitch[i], pending_note_vel[i]);

      // Track in correct variable based on note type
      is_harm ? (
        harmony_note_playing = pending_note_pitch[i];
      ) : (
        note_playing = pending_note_pitch[i];
      );

      // Remove from queue by shifting remaining notes down
      j = i;
      while (j < pending_note_count - 1) (
        pending_note_pitch[j] = pending_note_pitch[j + 1];
        pending_note_vel[j] = pending_note_vel[j + 1];
        pending_note_sample[j] = pending_note_sample[j + 1];
        pending_note_is_harmony[j] = pending_note_is_harmony[j + 1];
        j += 1;
      );
      pending_note_count -= 1;
      // Don't increment i since we shifted the array
    ) : (
      i += 1;
    );
  );
);

// Clear all pending notes (for seek/stop)
function clear_pending_notes() (
  pending_note_count = 0;
);

@slider
build_scale();

// Update progression chords from sliders
prog_chords[0] = slider9;
prog_chords[1] = slider10;
prog_chords[2] = slider11;
prog_chords[3] = slider12;

build_chord_tones();

@block
// ============================================
// HUMANIZATION: Process any pending delayed notes
// ============================================
process_pending_notes();

// ============================================
// PROGRESSION SEQUENCER
// ============================================
  // Calculate speed multiplier
  speed_mult = (slider15 == 0) ? 0.5 : (slider15 == 1) ? 1.0 : (slider15 == 2) ? 2.0 : (slider15 == 3) ? 4.0 : 8.0;
  
  // Detect speed change and reset state to prevent timing glitches
  speed_mult != last_speed_mult ? (
    last_speed_mult >= 0 ? ( // Don't reset on first run
      send_note_off(0);
      send_harmony_note_off(0);
      // Always clean up held notes and pedal (functions have internal guards)
      release_all_held_notes();
      send_pedal_off();
      phrase_active = 0;
      between_phrase_rest = 0;
    );
    last_speed_mult = speed_mult;
  );

  // Detect pedal modeling toggle - clean up when disabled
  slider20 != last_pedal_modeling ? (
    last_pedal_modeling >= 0 && slider20 == 0 ? (
      // Pedal modeling just turned OFF - clean up any held notes and pedal state
      release_all_held_notes();
      send_pedal_off();
    );
    last_pedal_modeling = slider20;
  );
  
  scaled_beat_pos = beat_position * speed_mult;

  // Calculate current beat number from beat_position
  beat_num = floor(scaled_beat_pos);

  // Absolute Grid Sequencing
  // Calculate which chord we are on based on absolute beat position
  beats_per_chord = floor(slider13 * 4 * speed_mult);
  
  // Handle negative beats (pre-roll) by clamping to 0
  abs_beat = max(0, beat_num);
  
  // Calculate progression position
  total_chords_passed = floor(abs_beat / beats_per_chord);
  prog_chord_index = total_chords_passed % slider8;
  prog_beat_counter = abs_beat % beats_per_chord;
  
  // Update current chord
  new_chord = prog_chords[prog_chord_index];
  
  // If chord changed, rebuild chord tones
  new_chord != prog_current_chord ? (
    prog_current_chord = new_chord;
    current_chord_idx = prog_current_chord;
    build_chord_tones();
    // Always clean up notes, held notes and pedal on chord change (functions have internal guards)
    send_note_off(0);
    send_harmony_note_off(0);
    release_all_held_notes();
    send_pedal_off();
    // Reset rest so new chord starts immediately if we were waiting
    between_phrase_rest = 0;
  );

  // Calculate beats remaining until chord change
  // Include fractional part for precision
  prog_beats_until_change = beats_per_chord - prog_beat_counter - (scaled_beat_pos - beat_num);

// Pass through incoming MIDI (always, regardless of generation state)
while(midirecv(offset, msg1, msg2, msg3)) (
  midisend(offset, msg1, msg2, msg3);
);

(slider21 == 1 && play_position > 0) ? ( // Generation enabled (skip if stopped)
  // Calculate current 8th-note slot from beat position
  current_eighth = floor(scaled_beat_pos * 2);

  // First playback after init/stop - send pedal off to clear any lingering state
  last_beat_position < 0 ? (
    // Force pedal off regardless of tracked state (clears external lingering pedal)
    midisend(0, $xB0 + (slider22 > 0 ? slider22 - 1 : 0), 64, 0);
    pedal_down = 0;
    held_count = 0;
    current_sample_pos = play_position * srate;  // Initialize sample position tracker
  );

  // Detect loop or seek (beat position jumped backwards or significantly forwards)
  (last_beat_position >= 0 && (beat_position < last_beat_position || beat_position > last_beat_position + 4)) ? (
    // Reset phrase state on seek/loop
    send_note_off(0);
    send_harmony_note_off(0);
    // Always clean up held notes and pedal (functions have internal guards)
    release_all_held_notes();
    send_pedal_off();
    clear_pending_notes();
    current_sample_pos = play_position * srate;  // Resync sample position
    phrase_active = 0;
    between_phrase_rest = 0;
    last_phrase_end_velocity = -1;
  );
  last_beat_position = beat_position;

  // New 8th note boundary?
  current_eighth != last_eighth ? (
    last_eighth = current_eighth;

    !phrase_active ? (
      // Not in phrase - handle rest countdown (on every 8th boundary)
      between_phrase_rest > 0 ? (
        between_phrase_rest -= 1;
      );

      // Only start phrases on quarter note boundaries (even 8th notes) to avoid syncopation
      (between_phrase_rest <= 0 && current_eighth % 2 == 0) ? (
        build_phrase_from_endpoint();
      );
    );

    phrase_active ? (
      // Set start beat on first tick of phrase
      phrase_start_beat < 0 ? (
        phrase_start_beat = current_eighth / 2;
        phrase_start_eighth = current_eighth;
        phrase_slot_index = 0;
        add_phrase_to_viz();
        // Press pedal at phrase start (only when pedal modeling enabled)
        slider20 == 1 ? (
          send_pedal_on();
          // Reset mud tracker for playback
          harmonic_mud = 0;
        );
      );

      // Calculate which slot we should be at (using integer math)
      phrase_slot_index = current_eighth - phrase_start_eighth;

      // Check and release any held notes that should end at this eighth (pedal modeling only)
      slider20 == 1 ? check_and_release_held_notes(current_eighth);

      // Still within phrase?
      phrase_slot_index < phrase_slot_count ? (
        // Get note and velocity for this slot
        note = phrase_events[phrase_slot_index];
        velocity = phrase_velocities[phrase_slot_index];

        // Handle pedal state from schedule (pedal modeling only)
        slider20 == 1 ? (
          phrase_pedal[phrase_slot_index] == 0 ? (
            // Scheduled pedal lift - clear non-chord tones
            send_pedal_off();
            // Brief pause then re-press (next slot will have pedal on by default)
          ) : (
            // Pedal should be down
            send_pedal_on();
          );
        );

        // Play if there's a note (0 = rest, -1 velocity = sustain)
        velocity != -1 ? (
          note > 0 ? (
            // Handle humanization timing offset
            humanize_offset = phrase_timing_offset[phrase_slot_index];

            humanize_offset < samplesblock ? (
              // Offset fits in current block - send immediately

              // Only send note-off if the previous note isn't being held (pedal modeling check)
              slider20 == 1 ? (
                !is_being_held(note_playing) ? send_note_off(max(0, humanize_offset - 1));
              ) : (
                send_note_off(max(0, humanize_offset - 1));
              );
              // Also stop previous harmony note
              send_harmony_note_off(max(0, humanize_offset - 1));

              send_note_on(note, velocity, humanize_offset);
            ) : (
              // Offset exceeds block - queue for future block
              queue_pending_note(note, velocity, current_sample_pos + humanize_offset, 0);
            );

            // === HARMONY NOTE PLAYBACK ===
            harmony_note = phrase_harmony_note[phrase_slot_index];
            harmony_note > 0 ? (
              // Calculate harmony timing: main note offset + slight random delay
              harmony_timing_offset = humanize_offset + floor((rand() * HARMONY_TIMING_OFFSET_MS) * srate / 1000);
              harmony_vel = floor(velocity * HARMONY_VEL_REDUCTION);
              harmony_vel = max(1, min(127, harmony_vel));

              harmony_timing_offset < samplesblock ? (
                // Send harmony note immediately
                midisend(harmony_timing_offset, $x90 + (slider22 > 0 ? slider22 - 1 : 0), harmony_note, harmony_vel);
                harmony_note_playing = harmony_note;
              ) : (
                // Queue harmony note for future block
                queue_pending_note(harmony_note, harmony_vel, current_sample_pos + harmony_timing_offset, 1);
              );

              // If main note is held, also hold harmony note (Option C: harmony follows main)
              slider20 == 1 && phrase_note_offs[phrase_slot_index] > phrase_slot_index ? (
                held_duration = phrase_note_offs[phrase_slot_index] - phrase_slot_index;
                held_duration = held_duration * phrase_duration_mod[phrase_slot_index];
                held_duration = max(1, held_duration);
                abs_end_eighth = phrase_start_eighth + phrase_slot_index + held_duration;
                add_to_held_notes(harmony_note, abs_end_eighth);
              );
            );

            // Check if this note should be held (extended chord tone, pedal modeling only)
            slider20 == 1 && phrase_note_offs[phrase_slot_index] > phrase_slot_index ? (
              // Calculate absolute eighth when this note should end
              // Apply duration variation: scale the held duration by duration_mod
              held_duration = phrase_note_offs[phrase_slot_index] - phrase_slot_index;
              held_duration = held_duration * phrase_duration_mod[phrase_slot_index];
              held_duration = max(1, held_duration);  // At least 1 eighth note
              abs_end_eighth = phrase_start_eighth + phrase_slot_index + held_duration;
              add_to_held_notes(note, abs_end_eighth);
            );
          ) : (
            // Rest (0) - stop previous note if playing (and not held)
            slider20 == 1 ? (
              !is_being_held(note_playing) ? send_note_off(0);
            ) : (
              send_note_off(0);
            );
            send_harmony_note_off(0);
          );
        );
      ) : (
        // Phrase complete - start rest period
        send_note_off(0);
        send_harmony_note_off(0);
        // Always clean up held notes and pedal (functions have internal guards)
        release_all_held_notes();
        send_pedal_off();
        phrase_active = 0;
        between_phrase_rest = phrase_rest_after;
      );
    );
  );
) : (
  // Playback stopped or generation disabled - reset for next start
  last_beat_position >= 0 ? (
    // Clean up on stop
    send_note_off(0);
    send_harmony_note_off(0);
    release_all_held_notes();
    send_pedal_off();
    clear_pending_notes();
    current_sample_pos = 0;
    last_beat_position = -1;
    phrase_active = 0;
    last_phrase_end_velocity = -1;
  );
);

// Update absolute sample position for next block (for humanization queue)
current_sample_pos += samplesblock;

@gfx 450 300
// ============================================
// GRAPHICS / UI
// ============================================

// Layout Constants
margin = 20;
header_h = 30;
chord_section_h = 70;
viz_h = 120;

// Clear background (Dark Grey)
gfx_set(0.1, 0.1, 0.1, 1);
gfx_rect(0, 0, gfx_w, gfx_h);

// Fonts
gfx_setfont(1, "Arial", 14);      // Label
gfx_setfont(2, "Arial", 32, 'b'); // Big Chord
gfx_setfont(3, "Arial", 18);      // Normal
gfx_setfont(4, "Arial", 12);      // Small

// 1. Header (Key & Scale)
gfx_x = margin; gfx_y = margin;
gfx_set(0.6, 0.6, 0.6, 1); // Dim text
gfx_setfont(1);
gfx_drawstr("KEY: ");
gfx_set(1, 1, 1, 1); // White
gfx_print_note_class(slider1);
gfx_drawstr(" ");
slider2 == 0 ? gfx_drawstr("Major") : slider2 == 1 ? gfx_drawstr("Minor") : gfx_drawstr("Lydian");

// 2. Chord Display
gfx_y += 30;
current_y = gfx_y;

// Current Chord
gfx_x = margin;
gfx_set(0.4, 0.8, 1.0, 1); // Blue label
gfx_setfont(1);
gfx_drawstr("CURRENT CHORD");
gfx_y += 20;
gfx_x = margin;
gfx_set(1, 1, 1, 1);
gfx_setfont(2);
display_current_chord = current_chord_idx;
gfx_print_chord_name(display_current_chord);

// Next Chord (if auto)
gfx_x = gfx_w / 2;
gfx_y = current_y;
gfx_set(0.4, 0.8, 1.0, 1);
gfx_setfont(1);
gfx_drawstr("NEXT CHORD");
gfx_y += 20;
gfx_x = gfx_w / 2;
gfx_set(0.7, 0.7, 0.7, 1); // Dimmer white
gfx_setfont(2);
display_next_chord = prog_chords[(prog_chord_index + 1) % slider8];
gfx_print_chord_name(display_next_chord);

// 3. Phrase Visualization
gfx_y = current_y + chord_section_h;
viz_y = gfx_y;
viz_w = gfx_w - 2*margin;

// Background for viz
gfx_set(0.15, 0.15, 0.15, 1);
gfx_rect(margin, viz_y, viz_w, viz_h);

// Settings for continuous view
speed_mult = (slider15 == 0) ? 0.5 : (slider15 == 1) ? 1.0 : (slider15 == 2) ? 2.0 : (slider15 == 3) ? 4.0 : 8.0;
scaled_beat_pos = beat_position * speed_mult;

beats_on_screen = 12; 
lookahead_beats = 8;
right_edge_beat = scaled_beat_pos + lookahead_beats;
left_edge_beat = right_edge_beat - beats_on_screen;

// Y-Axis Scaling (Fixed based on settings for stability)
min_note = get_base_note() - 2;
note_range = (slider4 * 12) + 4;

// Draw Grid (Quarter notes)
start_beat_int = floor(left_edge_beat);
loop_count = beats_on_screen + 2;
i = 0;
loop(loop_count,
  b = start_beat_int + i;
  x = margin + ((b - left_edge_beat) / beats_on_screen) * viz_w;
  (x >= margin && x <= margin + viz_w) ? (
    // Highlight downbeats (assuming 4/4)
    (b % 4 == 0) ? gfx_set(0.3, 0.3, 0.3, 1) : gfx_set(0.2, 0.2, 0.2, 1);
    gfx_line(x, viz_y, x, viz_y + viz_h);
  );
  i += 1;
);

// Draw Notes from History
i = 0;
loop(viz_buffer_size,
  idx = i; 
  n = viz_buffer_pitch[idx];
  
  n > 0 ? (
    t_start = viz_buffer_start[idx];
    t_len = viz_buffer_len[idx];
    t_end = t_start + t_len;
    
    // Check overlap with view
    (t_end > left_edge_beat && t_start < right_edge_beat) ? (
      // Calculate coords
      x1 = margin + ((t_start - left_edge_beat) / beats_on_screen) * viz_w;
      w = (t_len / beats_on_screen) * viz_w;
      
      // Clip to view
      x1 < margin ? ( w -= (margin - x1); x1 = margin; );
      (x1 + w) > (margin + viz_w) ? ( w = (margin + viz_w) - x1; );
      
      // Y coord
      norm_p = (n - min_note) / note_range;
      norm_p = max(0, min(1, norm_p));
      h = 8;
      y = viz_y + viz_h - (norm_p * (viz_h - 20)) - 15;
      
      // Color: Highlight if currently playing
      (scaled_beat_pos >= t_start && scaled_beat_pos < t_end) ? (
          gfx_set(1, 1, 1, 1);
      ) : (
          gfx_set(0.4, 0.8, 0.5, 0.8);
      );
      
      gfx_rect(x1, y, w, h);
    );
  );
  i += 1;
);

// Playhead
playhead_x = margin + ((scaled_beat_pos - left_edge_beat) / beats_on_screen) * viz_w;
(playhead_x >= margin && playhead_x <= margin + viz_w) ? (
  gfx_set(1, 0.3, 0.3, 0.8);
  gfx_rect(playhead_x, viz_y, 2, viz_h);
);

// Status Overlay
!slider21 ? (
  gfx_x = margin + 10; gfx_y = viz_y + 10;
  gfx_setfont(3); gfx_set(1, 0.5, 0.5, 1);
  gfx_drawstr("Generation Disabled");
) : (
  between_phrase_rest > 0 ? (
    gfx_x = margin + 10; gfx_y = viz_y + 10;
    gfx_setfont(4); gfx_set(0.7, 0.7, 0.7, 0.8);
    gfx_drawstr("Resting: ");
    gfx_printf("%d", between_phrase_rest);
  );
);

// 4. Footer / Status
gfx_y = viz_y + viz_h + 10;
gfx_x = margin;
gfx_setfont(4);
gfx_set(0.5, 0.5, 0.5, 1);
gfx_drawstr("Density: "); 
gfx_printf("%d%%", slider7 * 100);
gfx_drawstr("  |  Range: ");
gfx_printf("%d", slider4);
gfx_drawstr(" oct");
